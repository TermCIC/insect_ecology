<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG v0.0.7</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .hp-bar {
        font-size: 14px;
        text-align: center;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        width: 80vw;
        max-width: 480px;
    }

    #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        margin-bottom: 16px;
    }

    #controls .row {
        display: flex;
        gap: 4px;
    }

    #controls button {
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        cursor: pointer;
        min-width: 80px;
    }

    #controls button:active {
        background: #444;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>

<div id="game-wrapper">
    <div id="monster-hp" class="hp-bar">Monster HP: -</div>
    <div id="game">
        <canvas id="renderCanvas"></canvas>
    </div>
    <div id="player-hp" class="hp-bar">Player HP: 100/100</div>
    <div id="debug-angles" class="hp-bar">Cam: 0 | Fire spawn: - | Fire dir: -</div>
</div>

<div id="controls">
    <div class="row">
        <button id="btn-attack">âš”</button>
        <button id="btn-forward">â†‘</button>
        <button id="btn-potion">ðŸ§ª</button>
    </div>
    <div class="row">
        <button id="btn-turn-left">â†º</button>
        <button id="btn-back">â†“</button>
        <button id="btn-turn-right">â†»</button>
    </div>
</div>

<script>
// ===== Helpers =====
function normDeg(a) {
    a = a % 360;
    if (a < 0) a += 360;
    return a;
}

// ===== DOM =====
const playerHpEl = document.getElementById("player-hp");
const monsterHpEl = document.getElementById("monster-hp");
const debugAnglesEl = document.getElementById("debug-angles");

// ===== States =====
const player = { maxHp: 100, hp: 100, atk: 12 };
const monsterState = { maxHp: 40, hp: 40, atk: 6, alive: true, cooldown: 0 };

const ATTACK_RANGE = 3.0;
const FIREBALL_SPEED = 12;
const FIREBALL_RADIUS = 0.4;
const FIREBALL_LIFETIME = 3;

let lastFireSpawnAngleDeg = null;
let lastFireDirAngleDeg = null;

// ===== BabylonJS =====
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let scene, camera, monsterMesh;
const projectiles = [];

// Map and geometry constants
const MAP_SIZE = 10;
const TILE_SIZE = 2;
const HALF_MAP = MAP_SIZE / 2;

const FLOOR_THICKNESS = 0.2;
const WALL_HEIGHT = 3.0;        // walls from y = 0 to y = 3
const CEILING_THICKNESS = 0.2;
const CEILING_Y = WALL_HEIGHT;  // bottom of ceiling

const CAMERA_HEIGHT = 1.4;      // eye height above floor
const PLAYER_RADIUS = 0.8;      // slightly larger so you never visually overlap walls

// ===== Maps =====
const groundMap = [
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
];

const wallMap = [
    "##########",
    "#........#",
    "#...#....#",
    "#........#",
    "#........#",
    "#..###...#",
    "#........#",
    "#........#",
    "#........#",
    "##########",
];

const ceilingMap = groundMap;

const objectMap = [
    "..........",
    "..........",
    "...M......",
    "..........",
    "..........",
    "..........",
    "..........",
    "....P.....",
    "..........",
    "..........",
];

function gridToWorld(i, j) {
    const x = (j - HALF_MAP + 0.5) * TILE_SIZE;
    const z = (i - HALF_MAP + 0.5) * TILE_SIZE;
    return new BABYLON.Vector3(x, 0, z);
}

function worldToGrid(x, z) {
    const j = Math.floor(x / TILE_SIZE + HALF_MAP);
    const i = Math.floor(z / TILE_SIZE + HALF_MAP);
    return { i, j };
}

function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.collisionsEnabled = false;

    // Camera
    camera = new BABYLON.UniversalCamera(
        "playerCamera",
        new BABYLON.Vector3(0, CAMERA_HEIGHT, -8),
        scene
    );
    camera.inertia = 0;
    camera.checkCollisions = false;

    // Lights
    const hemi = new BABYLON.HemisphericLight(
        "hemi",
        new BABYLON.Vector3(0, 1, 0),
        scene
    );
    hemi.intensity = 0.8;

    // Textures
    const wallTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764056065/brick_wall_3_asxofr.png",
        scene
    );
    const floorTexture = new BABYLON.Texture(
        "https://opengameart.org/sites/default/files/Ground_02.png",
        scene
    );
    const ceilTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764057126/brick_wall_5_qtebvm.png",
        scene
    );

    const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
    wallMat.diffuseTexture = wallTexture;

    const floorMat = new BABYLON.StandardMaterial("floorMat", scene);
    floorMat.diffuseTexture = floorTexture;

    const ceilMat = new BABYLON.StandardMaterial("ceilMat", scene);
    ceilMat.diffuseTexture = ceilTexture;

    // Box options
    const wallBoxOptions = {
        width: TILE_SIZE,
        depth: TILE_SIZE,
        height: WALL_HEIGHT,
        wrap: true
    };

    const floorBoxOptions = {
        width: TILE_SIZE,
        depth: TILE_SIZE,
        height: FLOOR_THICKNESS
    };

    const ceilBoxOptions = {
        width: TILE_SIZE,
        depth: TILE_SIZE,
        height: CEILING_THICKNESS
    };

    let playerSpawn = null;

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const pos = gridToWorld(i, j);

            // Floor - thin slab around y = 0
            if (groundMap[i][j] === "#") {
                const floor = BABYLON.MeshBuilder.CreateBox(
                    `floor_${i}_${j}`,
                    floorBoxOptions,
                    scene
                );
                floor.position = new BABYLON.Vector3(
                    pos.x,
                    -FLOOR_THICKNESS / 2,
                    pos.z
                );
                floor.material = floorMat;
            }

            // Wall - tall box, bottom at y = 0
            if (wallMap[i][j] === "#") {
                const wall = BABYLON.MeshBuilder.CreateBox(
                    `wall_${i}_${j}`,
                    wallBoxOptions,
                    scene
                );
                wall.position = new BABYLON.Vector3(
                    pos.x,
                    WALL_HEIGHT / 2,
                    pos.z
                );
                wall.material = wallMat;
            }

            // Ceiling - thin slab at top
            if (ceilingMap[i][j] === "#") {
                const ceil = BABYLON.MeshBuilder.CreateBox(
                    `ceil_${i}_${j}`,
                    ceilBoxOptions,
                    scene
                );
                ceil.position = new BABYLON.Vector3(
                    pos.x,
                    CEILING_Y + CEILING_THICKNESS / 2,
                    pos.z
                );
                ceil.material = ceilMat;
            }

            // Objects
            if (objectMap[i][j] === "P") {
                playerSpawn = new BABYLON.Vector3(pos.x, CAMERA_HEIGHT, pos.z);
            }

            if (objectMap[i][j] === "M" && !monsterMesh) {
                monsterMesh = BABYLON.MeshBuilder.CreateBox(
                    "monster",
                    { width: TILE_SIZE * 0.8, depth: TILE_SIZE * 0.8, height: WALL_HEIGHT * 0.7 },
                    scene
                );
                monsterMesh.position = new BABYLON.Vector3(
                    pos.x,
                    WALL_HEIGHT * 0.35,
                    pos.z
                );
                const mMat = new BABYLON.StandardMaterial("mMat", scene);
                mMat.diffuseColor = new BABYLON.Color3(0.6, 0.1, 0.1);
                monsterMesh.material = mMat;
            }
        }
    }

    if (playerSpawn) {
        camera.position = playerSpawn.clone();
    }

    return scene;
}

scene = createScene();

// ===== Movement & Collision =====
const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

// Precise circle vs tile-AABB collision
function isCircleCollidingWithWalls(pos) {
    // If outside the map, treat as collision
    const grid = worldToGrid(pos.x, pos.z);
    if (grid.i < 0 || grid.i >= MAP_SIZE || grid.j < 0 || grid.j >= MAP_SIZE) {
        return true;
    }

    // Check nearby tiles (3x3 around player)
    for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
            const wi = grid.i + di;
            const wj = grid.j + dj;

            if (wi < 0 || wi >= MAP_SIZE || wj < 0 || wj >= MAP_SIZE) {
                continue;
            }
            if (wallMap[wi][wj] !== "#") continue;

            // World-space AABB for this wall tile
            const xMin = (wj - HALF_MAP) * TILE_SIZE;
            const xMax = xMin + TILE_SIZE;
            const zMin = (wi - HALF_MAP) * TILE_SIZE;
            const zMax = zMin + TILE_SIZE;

            // Closest point on the box to the circle center
            const cx = Math.max(xMin, Math.min(pos.x, xMax));
            const cz = Math.max(zMin, Math.min(pos.z, zMax));

            const dx = pos.x - cx;
            const dz = pos.z - cz;
            if (dx * dx + dz * dz < PLAYER_RADIUS * PLAYER_RADIUS) {
                return true;
            }
        }
    }
    return false;
}

function tryMove(stepVec) {
    const newPos = camera.position.add(stepVec);

    if (!isCircleCollidingWithWalls(newPos)) {
        camera.position = newPos;
    }
}

// ===== Input =====
let btnForwardHeld = false,
    btnBackHeld = false,
    btnTurnLeftHeld = false,
    btnTurnRightHeld = false;

const keys = { forward: false, back: false, left: false, right: false };

function bindHoldButton(id, setter) {
    const btn = document.getElementById(id);
    if (!btn) return;
    btn.addEventListener("mousedown", () => setter(true));
    btn.addEventListener("mouseup", () => setter(false));
    btn.addEventListener("mouseleave", () => setter(false));
    btn.addEventListener("touchstart", e => { e.preventDefault(); setter(true); });
    btn.addEventListener("touchend", e => { e.preventDefault(); setter(false); });
}

bindHoldButton("btn-forward", v => (btnForwardHeld = v));
bindHoldButton("btn-back", v => (btnBackHeld = v));
bindHoldButton("btn-turn-left", v => (btnTurnLeftHeld = v));
bindHoldButton("btn-turn-right", v => (btnTurnRightHeld = v));

window.addEventListener("keydown", e => {
    if (e.key === "w" || e.key === "ArrowUp") keys.forward = true;
    if (e.key === "s" || e.key === "ArrowDown") keys.back = true;
    if (e.key === "a" || e.key === "ArrowLeft") keys.left = true;
    if (e.key === "d" || e.key === "ArrowRight") keys.right = true;
});

window.addEventListener("keyup", e => {
    if (e.key === "w" || e.key === "ArrowUp") keys.forward = false;
    if (e.key === "s" || e.key === "ArrowDown") keys.back = false;
    if (e.key === "a" || e.key === "ArrowLeft") keys.left = false;
    if (e.key === "d" || e.key === "ArrowRight") keys.right = false;
});

// ===== Game loop =====
function update(dt) {
    // rotation
    if (btnTurnLeftHeld || keys.left) {
        camera.rotation.y -= TURN_SPEED * dt;
    }
    if (btnTurnRightHeld || keys.right) {
        camera.rotation.y += TURN_SPEED * dt;
    }

    // forward/back
    const forward = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
    const flat = new BABYLON.Vector3(forward.x, 0, forward.z).normalize();
    const step = MOVE_SPEED * dt;

    if (btnForwardHeld || keys.forward) {
        tryMove(flat.scale(step));
    }
    if (btnBackHeld || keys.back) {
        tryMove(flat.scale(-step));
    }
}

engine.runRenderLoop(() => {
    const dt = engine.getDeltaTime() / 1000;
    update(dt);
    scene.render();
});

window.addEventListener("resize", () => engine.resize());
</script>

</body>
</html>
