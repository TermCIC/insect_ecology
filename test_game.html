<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG v0.4.0</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .hp-bar {
        font-size: 14px;
        text-align: center;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        width: 80vw;
        max-width: 480px;
    }

    #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        margin-bottom: 16px;
    }

    #controls .row {
        display: flex;
        gap: 4px;
    }

    #controls button {
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        cursor: pointer;
        min-width: 80px;
    }

    #controls button:active {
        background: #444;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>

<div id="game-wrapper">
    <div id="game">
        <canvas id="renderCanvas"></canvas>
    </div>
    <div id="player-hp" class="hp-bar">Player HP: 100/100</div>
</div>

<div id="controls">
    <div class="row">
        <button id="btn-attack">âš”</button>
        <button id="btn-forward">â†‘</button>
        <button id="btn-potion">ðŸ§ª</button>
    </div>
    <div class="row">
        <button id="btn-turn-left">â†º</button>
        <button id="btn-back">â†“</button>
        <button id="btn-turn-right">â†»</button>
    </div>
</div>

<script>
/* ============================================================
   Load JSON from your GitHub assets.json
   ============================================================ */
let ASSETS = null;
let bgm = null;
let footstepLoop = null;

async function loadAssets() {
    try {
        const res = await fetch("https://termcic.github.io/insect_ecology/assets.json");
        ASSETS = await res.json();
        console.log("Assets loaded:", ASSETS);

        // audio
        if (ASSETS.audio?.bgm) {
            bgm = new Audio(ASSETS.audio.bgm);
            bgm.loop = true;
            bgm.volume = 0.03;
        }
        if (ASSETS.audio?.footstep) {
            footstepLoop = new Audio(ASSETS.audio.footstep);
            footstepLoop.loop = true;
            footstepLoop.volume = 0.95;
        }

    } catch (err) {
        console.error("Failed to load assets.json", err);
    }
}

/* ============================================================
   Base variables and DOM
   ============================================================ */

const playerHpEl = document.getElementById("player-hp");

const player = { maxHp: 100, hp: 100 };

const BASE_TORCH_INTENSITY = 1.25;
let torchTime = 0;

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let scene, camera, playerLight;

const MAP_SIZE = 30;
const TILE_SIZE = 2;
const HALF_MAP = MAP_SIZE / 2;

const FLOOR_THICKNESS = 0.2;
const WALL_HEIGHT = 3.0;
const CEILING_THICKNESS = 0.2;
const CEILING_Y = WALL_HEIGHT;

const CAMERA_HEIGHT = 1.4;
const PLAYER_RADIUS = 0.75;

let wantFootsteps = false;

/* ============================================================
   MAPS (unchanged)
   ============================================================ */

const groundMap = [...Array(30)].map(() => "##############################");
const ceilingMap = groundMap;

const wallMap = [
  "##############################",
  "#............#.##............#",
  "#............#..#............#",
  "#............#..#............#",
  "#............#..#............#",
  "#............##.#............#",
  "#............................#",
  "#..###.##..........######....#",
  "#..#....#...............#....#",
  "#..#....#....#.....#....#....#",
  "#..#....#....###...#....#....#",
  "#..####.#..........###.##....#",
  "#............................#",
  "#............####............#",
  "#............#..#............#",
  "#............#..#............#",
  "#............#...............#",
  "#............####............#",
  "#............................#",
  "#....#########....######.##..#",
  "#....#.......#....#.......#..#",
  "#....#.......#....#.......#..#",
  "#....#####.###....#########..#",
  "#............................#",
  "#............................#",
  "#............................#",
  "#............................#",
  "#............................#",
  "#............................#",
  "##############################"
];

/* --------- NEW: A/B/C monsters --------- */
const objectMap = [
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "...........A..................",
  "..............................",
  "..............................",
  "..............................",
  ".............B................",
  ".....................A........",
  "..............................",
  "..............................",
  "...............C..............",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "...............P..............",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  ".............................."
];

/* ============================================================
   Helpers
   ============================================================ */

function gridToWorld(i, j) {
    const x = (j - HALF_MAP + 0.5) * TILE_SIZE;
    const z = (i - HALF_MAP + 0.5) * TILE_SIZE;
    return new BABYLON.Vector3(x, 0, z);
}

function worldToGrid(x, z) {
    const j = Math.floor(x / TILE_SIZE + HALF_MAP);
    const i = Math.floor(z / TILE_SIZE + HALF_MAP);
    return { i, j };
}

/* ============================================================
   Monster System (billboard style)
   ============================================================ */

const monsters = [];

function createMonster(scene, worldPos, conf) {
    const plane = BABYLON.MeshBuilder.CreatePlane("monster", { size: conf.scale }, scene);

    plane.position = new BABYLON.Vector3(worldPos.x, 1.1, worldPos.z);
    plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;   // always face camera

    const tex = new BABYLON.Texture(conf.sprite, scene);
    tex.hasAlpha = true;

    const mat = new BABYLON.StandardMaterial("monsterMat", scene);
    mat.diffuseTexture = tex;
    mat.backFaceCulling = false;
    mat.useAlphaFromDiffuseTexture = true;

    plane.material = mat;

    return {
        mesh: plane,
        hp: conf.maxHp,
        maxHp: conf.maxHp,
        alive: true,
        cooldown: 0

        // === animation ===
        animFrame: 0,
        animTime: 0,
        animSpeed: conf.animSpeed ?? 8,  // frames per second
    };
}

function spawnMonsters(scene) {
    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const sym = objectMap[i][j];
            if (ASSETS.monsters[sym]) {
                const conf = ASSETS.monsters[sym];
                const pos = gridToWorld(i, j);
                monsters.push(createMonster(scene, pos, conf));
            }
        }
    }
}

/* ============================================================
   Create Scene â€” JSON-driven walls/floors/ceilings
   ============================================================ */

function createScene() {
    const scene = new BABYLON.Scene(engine);

    /* camera (unchanged) */
    camera = new BABYLON.UniversalCamera(
        "playerCamera",
        new BABYLON.Vector3(0, CAMERA_HEIGHT, -8),
        scene
    );
    camera.inertia = 0;
    camera.checkCollisions = false;
    camera.minZ = 0.01;

    /* ambient light */
    const hemi = new BABYLON.HemisphericLight("hemi",
        new BABYLON.Vector3(0, 1, 0), scene);
    hemi.intensity = 0.1;

    /* torch (unchanged) */
    playerLight = new BABYLON.PointLight(
        "playerTorch",
        new BABYLON.Vector3(0.4, 0.4, 1.0),
        scene
    );
    playerLight.parent = camera;
    playerLight.range = 10.5;
    playerLight.intensity = BASE_TORCH_INTENSITY;
    playerLight.diffuse  = new BABYLON.Color3(1.0, 0.82, 0.62);
    playerLight.specular = new BABYLON.Color3(0.25, 0.18, 0.12);
    playerLight.falloffType = BABYLON.Light.FALLOFF_STANDARD;

    /* build map */
    const wallOps = { width: TILE_SIZE, depth: TILE_SIZE, height: WALL_HEIGHT };
    const floorOps = { width: TILE_SIZE, depth: TILE_SIZE, height: FLOOR_THICKNESS };
    const ceilOps  = { width: TILE_SIZE, depth: TILE_SIZE, height: CEILING_THICKNESS };

    let playerSpawn = null;

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const pos = gridToWorld(i, j);

            // FLOOR
            if (groundMap[i][j] === "#") {
                const f = BABYLON.MeshBuilder.CreateBox(`f${i}_${j}`, floorOps, scene);
                f.position = new BABYLON.Vector3(pos.x, -FLOOR_THICKNESS/2, pos.z);

                const url = ASSETS.floors?.["#"];
                if (url) {
                    const m = new BABYLON.StandardMaterial(`fm${i}_${j}`, scene);
                    m.diffuseTexture = new BABYLON.Texture(url, scene);
                    f.material = m;
                }
            }

            // WALL
            if (wallMap[i][j] === "#") {
                const w = BABYLON.MeshBuilder.CreateBox(`w${i}_${j}`, wallOps, scene);
                w.position = new BABYLON.Vector3(pos.x, WALL_HEIGHT/2, pos.z);

                const url = ASSETS.walls?.["#"];
                if (url) {
                    const m = new BABYLON.StandardMaterial(`wm${i}_${j}`, scene);
                    m.diffuseTexture = new BABYLON.Texture(url, scene);
                    w.material = m;
                }
            }

            // CEILING
            if (ceilingMap[i][j] === "#") {
                const c = BABYLON.MeshBuilder.CreateBox(`c${i}_${j}`, ceilOps, scene);
                c.position = new BABYLON.Vector3(pos.x, CEILING_Y + CEILING_THICKNESS/2, pos.z);

                const url = ASSETS.ceilings?.["#"];
                if (url) {
                    const m = new BABYLON.StandardMaterial(`cm${i}_${j}`, scene);
                    m.diffuseTexture = new BABYLON.Texture(url, scene);
                    c.material = m;
                }
            }

            if (objectMap[i][j] === "P") {
                playerSpawn = new BABYLON.Vector3(pos.x, CAMERA_HEIGHT, pos.z);
            }
        }
    }

    if (playerSpawn)
        camera.position = playerSpawn.clone();

    return scene;
}

/* ============================================================
   Movement + collision
   ============================================================ */

const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

function isCircleCollidingWithWalls(pos) {
    const g = worldToGrid(pos.x, pos.z);
    if (g.i < 0 || g.i >= MAP_SIZE || g.j < 0 || g.j >= MAP_SIZE) return true;

    for (let di=-1; di<=1; di++) {
        for (let dj=-1; dj<=1; dj++) {
            const wi = g.i + di;
            const wj = g.j + dj;
            if (wi<0 || wi>=MAP_SIZE || wj<0 || wj>=MAP_SIZE) continue;
            if (wallMap[wi][wj] !== "#") continue;

            const xMin = (wj - HALF_MAP) * TILE_SIZE;
            const xMax = xMin + TILE_SIZE;
            const zMin = (wi - HALF_MAP) * TILE_SIZE;
            const zMax = zMin + TILE_SIZE;

            const cx = Math.max(xMin, Math.min(pos.x, xMax));
            const cz = Math.max(zMin, Math.min(pos.z, zMax));

            const dx = pos.x - cx;
            const dz = pos.z - cz;

            if (dx*dx + dz*dz < PLAYER_RADIUS*PLAYER_RADIUS)
                return true;
        }
    }
    return false;
}

function tryMove(step) {
    let moved = false;

    const px = camera.position.add(new BABYLON.Vector3(step.x, 0, 0));
    if (!isCircleCollidingWithWalls(px)) {
        camera.position.x = px.x;
        moved = true;
    }

    const pz = camera.position.add(new BABYLON.Vector3(0, 0, step.z));
    if (!isCircleCollidingWithWalls(pz)) {
        camera.position.z = pz.z;
        moved = true;
    }

    return moved;
}

/* ============================================================
   Input
   ============================================================ */

let btnForwardHeld = false,
    btnBackHeld = false,
    btnTurnLeftHeld = false,
    btnTurnRightHeld = false;

const keys = { forward:false, back:false, left:false, right:false };

function bindHold(id, setter) {
    const b = document.getElementById(id);
    b.addEventListener("mousedown", ()=>setter(true));
    b.addEventListener("mouseup",   ()=>setter(false));
    b.addEventListener("mouseleave",()=>setter(false));
    b.addEventListener("touchstart", e=>{ e.preventDefault(); setter(true); });
    b.addEventListener("touchend",   e=>{ e.preventDefault(); setter(false); });
}

bindHold("btn-forward", v => btnForwardHeld=v);
bindHold("btn-back",    v => btnBackHeld=v);
bindHold("btn-turn-left",  v => btnTurnLeftHeld=v);
bindHold("btn-turn-right", v => btnTurnRightHeld=v);

window.addEventListener("keydown", e => {
    if (e.key==="w"||e.key==="ArrowUp")    keys.forward = true;
    if (e.key==="s"||e.key==="ArrowDown")  keys.back    = true;
    if (e.key==="a"||e.key==="ArrowLeft")  keys.left    = true;
    if (e.key==="d"||e.key==="ArrowRight") keys.right   = true;
});

window.addEventListener("keyup", e => {
    if (e.key==="w"||e.key==="ArrowUp")    keys.forward = false;
    if (e.key==="s"||e.key==="ArrowDown")  keys.back    = false;
    if (e.key==="a"||e.key==="ArrowLeft")  keys.left    = false;
    if (e.key==="d"||e.key==="ArrowRight") keys.right   = false;
});

/* ============================================================
   Attack
   ============================================================ */

document.getElementById("btn-attack").onclick = () => {
    for (const m of monsters) {
        if (!m.alive) continue;

        const dx = camera.position.x - m.mesh.position.x;
        const dz = camera.position.z - m.mesh.position.z;
        const dist = Math.hypot(dx, dz);

        if (dist < 2.2) {
            m.hp -= 12;
            if (m.hp <= 0) {
                m.alive = false;
                m.mesh.dispose();
            }
        }
    }
};

/* ============================================================
   Monster animation
   ============================================================ */
function animateMonster(mon, dt) {
    mon.animTime += dt;

    const frames = 16;        // 4x4 sheet
    const perRow = 4;
    const frameDuration = 1 / mon.animSpeed;

    // advance frame
    while (mon.animTime >= frameDuration) {
        mon.animFrame = (mon.animFrame + 1) % frames;
        mon.animTime -= frameDuration;
    }

    // calculate UV offsets
    const fx = mon.animFrame % perRow;
    const fy = Math.floor(mon.animFrame / perRow);

    const u = fx * 0.25;
    const v = fy * 0.25;

    const tex = mon.mesh.material.diffuseTexture;
    tex.uOffset = u;
    tex.vOffset = v;
}
    
/* ============================================================
   Game Loop
   ============================================================ */

function update(dt) {
    // rotation
    if (btnTurnLeftHeld || keys.left)  camera.rotation.y -= TURN_SPEED * dt;
    if (btnTurnRightHeld || keys.right)camera.rotation.y += TURN_SPEED * dt;

    // movement
    const fwd = camera.getDirection(new BABYLON.Vector3(0,0,1));
    const flat = new BABYLON.Vector3(fwd.x, 0, fwd.z).normalize();
    const step = MOVE_SPEED * dt;

    let moved = false;
    if (btnForwardHeld || keys.forward) moved |= tryMove(flat.scale(step));
    if (btnBackHeld    || keys.back   ) moved |= tryMove(flat.scale(-step));

    // footsteps
    wantFootsteps = moved;
    if (footstepLoop) {
        if (wantFootsteps && footstepLoop.paused) footstepLoop.play().catch(()=>{});
        if (!wantFootsteps && !footstepLoop.paused) footstepLoop.pause();
    }

    // torch flicker (unchanged)
    torchTime += dt;
    const flicker =
        Math.sin(torchTime * 6.3) * 0.08 +
        Math.sin(torchTime * 11.1) * 0.05 +
        (Math.random() - 0.5) * 0.02;
    let intensity = BASE_TORCH_INTENSITY + flicker;
    intensity = Math.min(1.6, Math.max(0.95, intensity));
    playerLight.intensity = intensity;

    // monster AI
    for (const m of monsters) {
        if (!m.alive) continue;

        const dx = camera.position.x - m.mesh.position.x;
        const dz = camera.position.z - m.mesh.position.z;
        const dist = Math.hypot(dx, dz);

        if (dist < 8 && dist > 1.5) {
            const spd = 1.4 * dt;
            m.mesh.position.x += (dx/dist)*spd;
            m.mesh.position.z += (dz/dist)*spd;
        }

        if (dist < 1.5 && m.cooldown <= 0) {
            player.hp -= 4;
            m.cooldown = 1.2;
        }

        if (m.cooldown > 0) m.cooldown -= dt;
    }
    
    // animate monsters
    for (const m of monsters) {
        if (m.alive) animateMonster(m, dt);
    }

    playerHpEl.textContent = `Player HP: ${player.hp}/${player.maxHp}`;
}

/* ============================================================
   Start the game
   ============================================================ */

(async () => {
    await loadAssets();

    scene = createScene();
    spawnMonsters(scene);

    engine.runRenderLoop(() => {
        const dt = engine.getDeltaTime() / 1000;
        update(dt);
        scene.render();

        if (bgm && bgm.paused) bgm.play().catch(()=>{});
    });
})();

window.addEventListener("resize", () => engine.resize());
window.addEventListener("click", () => {
    if (bgm && bgm.paused) bgm.play().catch(()=>{});
});

</script>

</body>
</html>
