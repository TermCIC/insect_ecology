<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG v0.0.3</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .hp-bar {
        font-size: 14px;
        text-align: center;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        width: 80vw;
        max-width: 480px;
    }

    #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>

<div id="game-wrapper">
    <div id="monster-hp" class="hp-bar">Monster HP: -</div>
    <div id="game">
        <canvas id="renderCanvas"></canvas>
    </div>
    <div id="player-hp" class="hp-bar">Player HP: 100/100</div>
    <div id="debug-angles" class="hp-bar">Cam: 0 | Fire spawn: - | Fire dir: -</div>
</div>

<div id="controls">
    <div class="row">
        <button id="btn-attack">âš”</button>
        <button id="btn-forward">â†‘</button>
        <button id="btn-potion">ðŸ§ª</button>
    </div>
    <div class="row">
        <button id="btn-turn-left">â†º</button>
        <button id="btn-back">â†“</button>
        <button id="btn-turn-right">â†»</button>
    </div>
</div>

<script>
// ===== Helpers =====
function normDeg(a) {
    a = a % 360;
    if (a < 0) a += 360;
    return a;
}

// ===== DOM =====
const playerHpEl = document.getElementById("player-hp");
const monsterHpEl = document.getElementById("monster-hp");
const debugAnglesEl = document.getElementById("debug-angles");

// ===== States =====
const player = { maxHp: 100, hp: 100, atk: 12 };
const monsterState = { maxHp: 40, hp: 40, atk: 6, alive: true, cooldown: 0 };

const ATTACK_RANGE = 3.0;
const FIREBALL_SPEED = 12;
const FIREBALL_RADIUS = 0.4;
const FIREBALL_LIFETIME = 3;

let lastFireSpawnAngleDeg = null;
let lastFireDirAngleDeg = null;

// ===== BabylonJS =====
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let scene, camera, monsterMesh;
const projectiles = [];

const MAP_SIZE = 10;
const TILE_SIZE = 2;
const HALF_MAP = MAP_SIZE / 2;

const FLOOR_Y = 0;
const WALL_Y = TILE_SIZE;
const CEILING_Y = TILE_SIZE * 2;

// Player collision radius
const PLAYER_RADIUS = 0.45; // tighter fit

// ===== Maps =====
const groundMap = [
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
];

const wallMap = [
    "##########",
    "#........#",
    "#...#....#",
    "#........#",
    "#........#",
    "#..###...#",
    "#........#",
    "#........#",
    "#........#",
    "##########",
];

const ceilingMap = groundMap;

const objectMap = [
    "..........",
    "..........",
    "...M......",
    "..........",
    "..........",
    "..........",
    "..........",
    "....P.....",
    "..........",
    "..........",
];

function gridToWorld(i, j) {
    const x = (j - HALF_MAP + 0.5) * TILE_SIZE;
    const z = (i - HALF_MAP + 0.5) * TILE_SIZE;
    return new BABYLON.Vector3(x, 0, z);
}

function worldToGrid(x, z) {
    const j = Math.floor(x / TILE_SIZE + HALF_MAP);
    const i = Math.floor(z / TILE_SIZE + HALF_MAP);
    return { i, j };
}

function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.collisionsEnabled = false;

    // === FIX 1: lower camera (no more clipping into walls) ===
    camera = new BABYLON.UniversalCamera("playerCamera", new BABYLON.Vector3(0, 1.0, -8), scene);
    camera.inertia = 0;
    camera.checkCollisions = false;

    // Lights
    new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene).intensity = 0.7;

    // Textures
    const wallTexture = new BABYLON.Texture("https://res.cloudinary.com/dmdpjf8up/image/upload/v1764056065/brick_wall_3_asxofr.png", scene);
    const floorTexture = new BABYLON.Texture("https://res.cloudinary.com/dmdpjf8up/image/upload/v1764056933/brick_wall_4_xuoebx.png", scene);
    const ceilTexture = new BABYLON.Texture("https://res.cloudinary.com/dmdpjf8up/image/upload/v1764057126/brick_wall_5_qtebvm.png", scene);

    const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
    wallMat.diffuseTexture = wallTexture;

    const floorMat = new BABYLON.StandardMaterial("floorMat", scene);
    floorMat.diffuseTexture = floorTexture;

    const ceilMat = new BABYLON.StandardMaterial("ceilMat", scene);
    ceilMat.diffuseTexture = ceilTexture;

    // === FIX 2: consistent UV orientation for walls ===
    const wallUV = {
        faceUV: [
            new BABYLON.Vector4(0,0,1,1),
            new BABYLON.Vector4(0,0,1,1),
            new BABYLON.Vector4(0,0,1,1),
            new BABYLON.Vector4(0,0,1,1),
            new BABYLON.Vector4(0,0,1,1),
            new BABYLON.Vector4(0,0,1,1)
        ]
    };

    // Build world
    let playerSpawn = null;

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const pos = gridToWorld(i, j);

            if (groundMap[i][j] === "#") {
                const b = BABYLON.MeshBuilder.CreateBox(`floor_${i}_${j}`, { size: TILE_SIZE }, scene);
                b.position = new BABYLON.Vector3(pos.x, FLOOR_Y, pos.z);
                b.material = floorMat;
            }

            if (wallMap[i][j] === "#") {
                const b = BABYLON.MeshBuilder.CreateBox(`wall_${i}_${j}`, { size: TILE_SIZE, ...wallUV }, scene);
                b.position = new BABYLON.Vector3(pos.x, WALL_Y, pos.z);
                b.material = wallMat;
            }

            if (ceilingMap[i][j] === "#") {
                const b = BABYLON.MeshBuilder.CreateBox(`ceil_${i}_${j}`, { size: TILE_SIZE }, scene);
                b.position = new BABYLON.Vector3(pos.x, CEILING_Y, pos.z);
                b.material = ceilMat;
            }

            if (objectMap[i][j] === "P") {
                playerSpawn = new BABYLON.Vector3(pos.x, 1.0, pos.z);
            }

            if (objectMap[i][j] === "M" && !monsterMesh) {
                monsterMesh = BABYLON.MeshBuilder.CreateBox("monster", { size: TILE_SIZE * 0.8 }, scene);
                monsterMesh.position = new BABYLON.Vector3(pos.x, 1.0, pos.z);
                monsterMesh.material = new BABYLON.StandardMaterial("mMat", scene);
                monsterMesh.material.diffuseColor = new BABYLON.Color3(0.6,0.1,0.1);
            }
        }
    }

    if (playerSpawn) camera.position = playerSpawn.clone();

    return scene;
}

scene = createScene();

// ===== Movement & Collision =====
const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

function tryMove(stepVec) {
    const newPos = camera.position.add(stepVec);

    // === FIX 3: circular collision check ===
    const checks = [
        newPos,
        newPos.add(new BABYLON.Vector3(PLAYER_RADIUS,0,0)),
        newPos.add(new BABYLON.Vector3(-PLAYER_RADIUS,0,0)),
        newPos.add(new BABYLON.Vector3(0,0,PLAYER_RADIUS)),
        newPos.add(new BABYLON.Vector3(0,0,-PLAYER_RADIUS))
    ];

    for (let c of checks) {
        const { i, j } = worldToGrid(c.x, c.z);
        if (wallMap[i][j] === "#") return;
    }

    camera.position = newPos;
}

// ===== Movement Input =====
let btnForwardHeld=false, btnBackHeld=false, btnTurnLeftHeld=false, btnTurnRightHeld=false;
const keys = {forward:false, back:false, left:false, right:false};

function bindHoldButton(id, setter){
    const btn=document.getElementById(id);
    btn.onmousedown=()=>setter(true);
    btn.onmouseup=()=>setter(false);
}

bindHoldButton("btn-forward", v=>btnForwardHeld=v);
bindHoldButton("btn-back", v=>btnBackHeld=v);
bindHoldButton("btn-turn-left", v=>btnTurnLeftHeld=v);
bindHoldButton("btn-turn-right", v=>btnTurnRightHeld=v);

window.addEventListener("keydown", e=>{
    if (e.key==="w"||e.key==="ArrowUp") keys.forward=true;
    if (e.key==="s"||e.key==="ArrowDown") keys.back=true;
    if (e.key==="a"||e.key==="ArrowLeft") keys.left=true;
    if (e.key==="d"||e.key==="ArrowRight") keys.right=true;
});
window.addEventListener("keyup", e=>{
    if (e.key==="w"||e.key==="ArrowUp") keys.forward=false;
    if (e.key==="s"||e.key==="ArrowDown") keys.back=false;
    if (e.key==="a"||e.key==="ArrowLeft") keys.left=false;
    if (e.key==="d"||e.key==="ArrowRight") keys.right=false;
});

// ===== Game Loop =====
function update(dt){
    if (btnTurnLeftHeld || keys.left) camera.rotation.y -= TURN_SPEED*dt;
    if (btnTurnRightHeld || keys.right) camera.rotation.y += TURN_SPEED*dt;

    const forward = camera.getDirection(new BABYLON.Vector3(0,0,1));
    const flat = new BABYLON.Vector3(forward.x,0,forward.z).normalize();
    const step = MOVE_SPEED * dt;

    if (btnForwardHeld || keys.forward) tryMove(flat.scale(step));
    if (btnBackHeld || keys.back) tryMove(flat.scale(-step));
}

engine.runRenderLoop(()=>{
    const dt=engine.getDeltaTime()/1000;
    update(dt);
    scene.render();
});

</script>
</body>
</html>
