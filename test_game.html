<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KAPLAY 3D Fullscreen Stable</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/kaplay/dist/kaplay.js"></script>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: black;
        width: 100%;
        height: 100%;
    }
</style>
</head>

<body>
<script>
kaplay({
    stretch: true,
    letterbox: false,
    scale: 1,
});

// Load textures
loadSprite("bean", "https://play.kaplayjs.com/sprites/bean.png");
loadSprite("wall", "https://play.kaplayjs.com/sprites/brick_wall.png");

let bean, objSlices = [];
let wall, wallSlices = [];

// Load textures
onLoad(() => {
    bean = getSprite("bean").data;
    for (let i = 0; i < bean.width; i++) {
        objSlices.push(
            bean.frames[0].scale(new Quad(i / bean.width, 0, 1 / bean.width, 1))
        );
    }

    wall = getSprite("wall").data;
    for (let i = 0; i < wall.width; i++) {
        wallSlices.push(
            wall.frames[0].scale(new Quad(i / wall.width, 0, 1 / wall.width, 1))
        );
    }
});

// ---- Raycaster core (unchanged except safe math) ----

function rayCastGrid(origin, direction, hitFunc, maxDist = 64) {
    const step = vec2(direction.x > 0 ? 1 : -1, direction.y > 0 ? 1 : -1);
    const grid = vec2(Math.floor(origin.x), Math.floor(origin.y));
    const inv = vec2(
        direction.x === 0 ? 1e9 : Math.abs(1 / direction.x),
        direction.y === 0 ? 1e9 : Math.abs(1 / direction.y)
    );
    let distX = (step.x > 0) ? (grid.x + 1 - origin.x) : (origin.x - grid.x);
    let distY = (step.y > 0) ? (grid.y + 1 - origin.y) : (origin.y - grid.y);
    let maxX = inv.x * distX;
    let maxY = inv.y * distY;

    while (true) {
        const hit = hitFunc(grid);
        if (hit) {
            return {
                t: Math.min(maxX, maxY),
                gridPos: vec2(grid.x, grid.y),
            };
        }
        if (maxX < maxY) {
            grid.x += step.x;
            maxX += inv.x;
        } else {
            grid.y += step.y;
            maxY += inv.y;
        }
        if (grid.x < 0 || grid.y < 0 || grid.x > 50 || grid.y > 50) return null;
    }
}

const colors = {
    "#": RED,
    "$": GREEN,
    "%": BLUE,
    "&": YELLOW,
};

const grid = [
"##################",
"#                #",
"# $$$$$$$ $$$$$$ #",
"# $            $ #",
"# $ %% %%%%%%% $ #",
"# $ %        % $ #",
"#&$&%%%%%  %%%&$&#",
"# $ %          $ #",
"# $ %%%%%%%%%%   #",
"# $            $ #",
"# $$$$$$$ $$$$$$ #",
"#          &     #",
"##################",
];

function isWall(x, y) {
    if (y < 0 || y >= grid.length) return false;
    if (x < 0 || x >= grid[0].length) return false;
    return grid[y][x] !== " " && grid[y][x] !== "&";
}

// ---- Camera ----

const cam = add([
    pos(7 * 16, 11 * 16),
    rotate(0),
    {
        fov: 0.8,          // radians
        speed: 80,
        height: 16,
        draw() {
            const W = width();
            const H = height();
            const halfH = H / 2;

            pushTransform();

            // Sky
            drawRect({
                width: W,
                height: halfH,
                color: rgb(100,100,100)
            });

            // Floor
            drawRect({
                pos: vec2(0, halfH),
                width: W,
                height: halfH,
                color: rgb(60,60,60)
            });

            // Cast one ray per vertical column
            for (let x = 0; x < W; x++) {

                const cameraX = (2 * x) / W - 1;
                const angle = this.angle + cameraX * this.fov;

                const dir = Vec2.fromAngle(angle);

                const hit = rayCastGrid(
                    this.pos.scale(1/16),
                    dir,
                    ({x,y})=>isWall(x,y)
                );

                if (!hit) continue;

                const dist = hit.t * 16;

                // Projection
                const wallHeight = Math.min(H, (1000 / (dist + 0.0001)));

                let u = ((this.pos.y + dir.y * dist) % 16) / 16;
                if (u < 0) u += 1;

                const slice = wallSlices[Math.floor(u * (wall.width-1))];

                drawUVQuad({
                    pos: vec2(x, halfH - wallHeight/2),
                    width: 1,
                    height: wallHeight,
                    tex: wall.tex,
                    quad: slice,
                    color: WHITE,
                });
            }

            popTransform();
        }
    }
]);

// Movement
onKeyDown("up",   ()=> cam.pos = cam.pos.add(Vec2.fromAngle(cam.angle).scale(cam.speed * dt())));
onKeyDown("down", ()=> cam.pos = cam.pos.add(Vec2.fromAngle(cam.angle).scale(-cam.speed * dt())));
onKeyDown("left", ()=> cam.angle -= 1.5 * dt());
onKeyDown("right",()=> cam.angle += 1.5 * dt());

</script>
</body>
</html>