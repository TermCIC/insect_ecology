<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KAPLAY 3D Example</title>
<script src="https://unpkg.com/kaplay/dist/kaplay.js"></script>
</head>

<body style="margin:0;background:black;">
<script>
kaplay();

// Load sprites using ABSOLUTE URLs from play.kaplayjs.com
loadSprite("bean", "https://play.kaplayjs.com/sprites/bean.png");
loadSprite("wall", "https://play.kaplayjs.com/sprites/brick_wall.png");
loadSprite("floor", "https://play.kaplayjs.com/sprites/brick_wall.png");   // ★ NEW

let bean;
let objSlices = [];
let wall;
let slices = [];
let floor;
let floorSlices = [];   // ★ NEW

onLoad(() => {
    bean = getSprite("bean").data;
    for (let i = 0; i < bean.width; i++) {
        objSlices.push(
            bean.frames[0].scale(
                new Quad(i / bean.width, 0, 1 / bean.width, 1),
            ),
        );
    }

    wall = getSprite("wall").data;
    for (let i = 0; i < wall.width; i++) {
        slices.push(
            wall.frames[0].scale(
                new Quad(i / wall.width, 0, 1 / wall.width, 1),
            ),
        );
    }

    // ★ FLOOR TEXTURE SLICES
    floor = getSprite("floor").data;
    for (let i = 0; i < floor.width; i++) {
        floorSlices.push(
            floor.frames[0].scale(
                new Quad(i / floor.width, 0, 1 / floor.width, 1),
            ),
        );
    }
});


// ============================
//  (原本的 raycast functions 保留)
// ============================

function rayCastGrid(origin, direction, gridPosHit, maxDistance = 64) {
    const len = direction.len();
    const dir = direction.scale(1 / len);
    let t = 0;
    let gridPos = vec2(Math.floor(origin.x), Math.floor(origin.y));
    const step = vec2(dir.x > 0 ? 1 : -1, dir.y > 0 ? 1 : -1);
    const tDelta = vec2(Math.abs(1 / dir.x), Math.abs(1 / dir.y));
    let dist = vec2(
        (step.x > 0) ? (gridPos.x + 1 - origin.x) : (origin.x - gridPos.x),
        (step.y > 0) ? (gridPos.y + 1 - origin.y) : (origin.y - gridPos.y),
    );
    let tMax = vec2(
        (tDelta.x < Infinity) ? tDelta.x * dist.x : Infinity,
        (tDelta.y < Infinity) ? tDelta.y * dist.y : Infinity,
    );
    let steppedIndex = -1;

    while (t <= maxDistance) {
        const hit = gridPosHit(gridPos);
        if (hit === true) {
            return {
                point: origin.add(dir.scale(t)),
                normal: vec2(steppedIndex === 0 ? -step.x : 0, steppedIndex === 1 ? -step.y : 0),
                t: t / len,
                gridPos,
            };
        }
        else if (hit) return hit;

        if (tMax.x < tMax.y) {
            gridPos.x += step.x;
            t = tMax.x;
            tMax.x += tDelta.x;
            steppedIndex = 0;
        } else {
            gridPos.y += step.y;
            t = tMax.y;
            tMax.y += tDelta.y;
            steppedIndex = 1;
        }
    }
    return null;
}

function raycastEdge(origin, direction, line) {
    const a = origin;
    const c = line.p1.add(line.pos);
    const d = line.p2.add(line.pos);

    const ab = direction;
    const cd = d.sub(c);

    let abxcd = ab.cross(cd);
    if (Math.abs(abxcd) < Number.EPSILON) return false;

    const ac = c.sub(a);
    const s = ac.cross(cd) / abxcd;
    if (s <= 0 || s >= 1) return false;
    const t = ac.cross(ab) / abxcd;
    if (t <= 0 || t >= 1) return false;

    const normal = cd.normal().unit();
    if (direction.dot(normal) > 0) normal.x *= -1, normal.y *= -1;

    return {
        point: a.add(ab.scale(s)),
        normal,
        t: s,
        s: t,
        object: line,
    };
}

function rayCastAsciiGrid(origin, direction, grid) {

    origin = origin.scale(1 / 16);
    direction = direction.scale(1 / 16);

    const objects = [];

    const hit = rayCastGrid(origin, direction, ({ x, y }) => {
        if (y >= 0 && y < grid.length) {
            const row = grid[y];
            if (x >= 0 && x < row.length) {

                if (row[x] === "&") {
                    const perp = direction.normal().unit();
                    const planeP1 = perp.scale(-0.2);
                    const planeP2 = perp.scale(0.2);
                    const objectHit = raycastEdge(origin, direction, {
                        pos: vec2(x + 0.5, y + 0.5),
                        p1: planeP1,
                        p2: planeP2,
                    });
                    if (objectHit) objects.push(objectHit);
                }

                return row[x] !== " " && row[x] !== "&";
            }
        }
    }, direction.len());

    if (hit) {
        hit.point = hit.point.scale(16);
        hit.object = { color: colors[grid[hit.gridPos.y][hit.gridPos.x]] };
        hit.objects = objects;
    }
    return hit;
}


// ======================
// Colors
// ======================
const colors = {
    "#": RED,
    "$": GREEN,
    "%": BLUE,
    "&": YELLOW,
};


// ======================
// MAP
// ======================
const grid = [
    "##################",
    "#                #",
    "# $$$$$$$ $$$$$$ #",
    "# $            $ #",
    "# $ %% %%%%%%% $ #",
    "# $ %        % $ #",
    "#&$&%%%%%  %%%&$&#",
    "# $ %          $ #",
    "# $ %%%%%%%%%%   #",
    "# $            $ #",
    "# $$$$$$$ $$$$$$ #",
    "#          &     #",
    "##################",
];


// ======================
// CAMERA / RAYCAST RENDER
// ======================
const camera = add([
    pos(7 * 16, 11 * 16 + 8),
    rotate(0),
    z(-1),
    rect(8, 8),
    anchor("center"),
    area(),
    opacity(0),
    body(),
    {
        draw() {

            pushTransform();
            pushRotate(-this.angle);

            // Player direction / camera plane
            const dir = Vec2.fromAngle(this.angle);
            const perp = dir.normal();
            const planeP1 = this.pos.add(dir.scale(this.focalLength)).add(perp.scale(this.fov)).sub(this.pos);
            const planeP2 = this.pos.add(dir.scale(this.focalLength)).sub(perp.scale(this.fov)).sub(this.pos);

            // === SKY ===
            drawRect({
                width: 240,
                height: 120,
                color: rgb(100, 100, 100),
            });

            // === FLOOR TEXTURE (NEW!) ===
            for (let x = 0; x <= 120; x++) {
                for (let y = 120; y <= 240; y += 2) {

                    // pseudo perspective
                    let rowDist = 240 / (y - 120);

                    let floorPos = this.pos.add(
                        dir.scale(rowDist)
                           .add(perp.scale((x - 60) / 60 * this.fov))
                    );

                    // texture sampling UV
                    let u = ((floorPos.x % 16) + 16) % 16 / 16;
                    let v = ((floorPos.y % 16) + 16) % 16 / 16;

                    let quad = floorSlices[Math.floor(u * (floor.width - 1))];

                    drawUVQuad({
                        width: 2,
                        height: 2,
                        pos: vec2(x * 2, y),
                        tex: floor.tex,
                        quad: quad,
                    });
                }
            }

            // ============================
            // WALL RENDERING
            // ============================
            for (let x = 0; x <= 120; x++) {
                let direction = lerp(planeP1, planeP2, x / 120).scale(6);

                const hit = rayCastAsciiGrid(this.pos, direction, grid);
                if (!hit) continue;

                const t = hit.t;
                const d = (1 - t) * ((hit.normal.x + hit.normal.y) < 0 ? 0.5 : 1);

                let u = Math.abs(hit.normal.x) > Math.abs(hit.normal.y)
                    ? hit.point.y
                    : hit.point.x;

                u = (u % 16) / 16;
                u = u - Math.floor(u);

                const h = 240 / (t * direction.len() / 16);

                drawUVQuad({
                    width: 2,
                    height: h,
                    pos: vec2(x * 2, 120 - h / 2),
                    tex: wall.tex,
                    quad: slices[Math.round(u * (wall.width - 1))],
                    color: BLACK.lerp(WHITE, d),
                });

                if (hit.objects) {
                    hit.objects.reverse().forEach(o => {
                        const t = o.t;
                        const wh = 240 / (t * direction.len() / 16);
                        const oh = 140 / (t * direction.len() / 16);

                        let u = o.s;

                        drawUVQuad({
                            width: 2,
                            height: oh,
                            pos: vec2(x * 2, 120 + wh / 2 - oh),
                            tex: bean.tex,
                            quad: objSlices[Math.round(u * (bean.width - 1))],
                            color: BLACK.lerp(WHITE, u),
                        });
                    });
                }
            }

            popTransform();
        },
        focalLength: 40,
        fov: 10,
    },
]);


// ======================
// Physics grid (unchanged)
addLevel(grid, {
    pos: vec2(0, 0),
    tileWidth: 16,
    tileHeight: 16,
    tiles: {
        "#": () => [rect(16, 16), color(RED), area(), body({ isStatic: true })],
        "$": () => [rect(16, 16), color(GREEN), area(), body({ isStatic: true })],
        "%": () => [rect(16, 16), color(BLUE), area(), body({ isStatic: true })],
        "&": () => [pos(4, 4), rect(8, 8), color(YELLOW)],
    },
});


// ======================
// CAMERA CONTROLS
// ======================
onKeyDown("up", () => camera.move(Vec2.fromAngle(camera.angle).scale(40)));
onKeyDown("down", () => camera.move(Vec2.fromAngle(camera.angle).scale(-40)));
onKeyDown("left", () => camera.angle -= 90 * dt());
onKeyDown("right", () => camera.angle += 90 * dt());
onKeyDown("f", () => camera.focalLength = Math.max(1, camera.focalLength - 10 * dt()));
onKeyDown("g", () => camera.focalLength += 10 * dt());
onKeyDown("r", () => camera.fov = Math.max(1, camera.fov - 10 * dt()));
onKeyDown("t", () => camera.fov += 10 * dt());
onKeyDown("p", () => debug.paused = !debug.paused);


let lastPos = vec2();

onTouchStart(pos => lastPos = pos);

onTouchMove(pos => {
    const delta = pos.sub(lastPos);

    if (delta.x < 0) camera.angle -= 90 * dt();
    else if (delta.x > 0) camera.angle += 90 * dt();

    if (delta.y < 0) camera.move(Vec2.fromAngle(camera.angle).scale(40));
    else if (delta.y > 0) camera.move(Vec2.fromAngle(camera.angle).scale(-40));

    lastPos = pos;
});

</script>
</body>
</html>