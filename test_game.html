<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KAPLAY 3D Fullscreen</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<script src="https://unpkg.com/kaplay/dist/kaplay.js"></script>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: black;
        width: 100%;
        height: 100%;
    }
    canvas {
        display: block;
    }
</style>
</head>

<body>
<script>

// --- Fullscreen kaplay ---
kaplay({
    width: window.innerWidth,
    height: window.innerHeight,
    stretch: true,         // fullscreen stretch
    letterbox: false,
    scale: 1,
});

// Load sprites
loadSprite("bean", "https://play.kaplayjs.com/sprites/bean.png");
loadSprite("wall", "https://play.kaplayjs.com/sprites/brick_wall.png");

// ------------------------------
// Your variables (unchanged)
// ------------------------------
let bean;
let objSlices = [];
let wall;
let slices = [];

// When loaded, slice textures
onLoad(() => {
    bean = getSprite("bean").data;
    for (let i = 0; i < bean.width; i++) {
        objSlices.push(
            bean.frames[0].scale(
                new Quad(i / bean.width, 0, 1 / bean.width, 1)
            ),
        );
    }

    wall = getSprite("wall").data;
    for (let i = 0; i < wall.width; i++) {
        slices.push(
            wall.frames[0].scale(
                new Quad(i / wall.width, 0, 1 / wall.width, 1)
            ),
        );
    }
});

// ----------------------------------------------------------
// Below is YOUR raycaster code — unchanged except viewport size
// ----------------------------------------------------------

function rayCastGrid(origin, direction, gridPosHit, maxDistance = 64) {
    const pos = origin;
    const len = direction.len();
    const dir = direction.scale(1 / len);
    let t = 0;
    let gridPos = vec2(Math.floor(origin.x), Math.floor(origin.y));
    const step = vec2(dir.x > 0 ? 1 : -1, dir.y > 0 ? 1 : -1);
    const tDelta = vec2(Math.abs(1 / dir.x), Math.abs(1 / dir.y));
    let dist = vec2(
        (step.x > 0) ? (gridPos.x + 1 - origin.x) : (origin.x - gridPos.x),
        (step.y > 0) ? (gridPos.y + 1 - origin.y) : (origin.y - gridPos.y)
    );
    let tMax = vec2(
        (tDelta.x < Infinity) ? tDelta.x * dist.x : Infinity,
        (tDelta.y < Infinity) ? tDelta.y * dist.y : Infinity
    );
    let steppedIndex = -1;

    while (t <= maxDistance) {
        const hit = gridPosHit(gridPos);
        if (hit === true) {
            return {
                point: pos.add(dir.scale(t)),
                normal: vec2(
                    steppedIndex === 0 ? -step.x : 0,
                    steppedIndex === 1 ? -step.y : 0
                ),
                t: t / len,
                gridPos,
            };
        } else if (hit) {
            return hit;
        }

        if (tMax.x < tMax.y) {
            gridPos.x += step.x;
            t = tMax.x;
            tMax.x += tDelta.x;
            steppedIndex = 0;
        } else {
            gridPos.y += step.y;
            t = tMax.y;
            tMax.y += tDelta.y;
            steppedIndex = 1;
        }
    }
    return null;
}

function raycastEdge(origin, direction, line) {
    const a = origin;
    const c = line.p1.add(line.pos);
    const d = line.p2.add(line.pos);
    const ab = direction;
    const cd = d.sub(c);
    let abxcd = ab.cross(cd);
    if (Math.abs(abxcd) < Number.EPSILON) return false;

    const ac = c.sub(a);
    const s = ac.cross(cd) / abxcd;
    if (s <= 0 || s >= 1) return false;
    const t = ac.cross(ab) / abxcd;
    if (t <= 0 || t >= 1) return false;

    const normal = cd.normal().unit();
    if (direction.dot(normal) > 0) {
        normal.x *= -1;
        normal.y *= -1;
    }

    return {
        point: a.add(ab.scale(s)),
        normal,
        t: s,
        s: t,
        object: line,
    };
}

// -------------------
// Ascii wall grid
// -------------------
const grid = [
    "##################",
    "#                #",
    "# $$$$$$$ $$$$$$ #",
    "# $            $ #",
    "# $ %% %%%%%%% $ #",
    "# $ %        % $ #",
    "#&$&%%%%%  %%%&$&#",
    "# $ %          $ #",
    "# $ %%%%%%%%%%   #",
    "# $            $ #",
    "# $$$$$$$ $$$$$$ #",
    "#          &     #",
    "##################",
];

const colors = {
    "#": RED,
    "$": GREEN,
    "%": BLUE,
    "&": YELLOW,
};

// ----------------------------
// Camera • fullscreen viewport
// ----------------------------
const VIEW_WIDTH = window.innerWidth;
const VIEW_HEIGHT = window.innerHeight;

const camera = add([
    pos(7 * 16, 11 * 16 + 8),
    rotate(0),
    z(-1),
    rect(8, 8),
    anchor("center"),
    opacity(0),
    {
        focalLength: 40,
        fov: 10,

        draw() {
            pushTransform();
            pushRotate(-this.angle);

            const dir = Vec2.fromAngle(this.angle);
            const perp = dir.normal();

            const planeP1 = this.pos.add(dir.scale(this.focalLength)).add(perp.scale(this.fov)).sub(this.pos);
            const planeP2 = this.pos.add(dir.scale(this.focalLength)).sub(perp.scale(this.fov)).sub(this.pos);

            pushTranslate(this.pos.scale(-1).add(VIEW_WIDTH / 2, VIEW_HEIGHT / 2));

            // Top bottom background
            drawRect({
                width: VIEW_WIDTH,
                height: VIEW_HEIGHT / 2,
                color: rgb(100, 100, 100),
            });

            drawRect({
                pos: vec2(0, VIEW_HEIGHT / 2),
                width: VIEW_WIDTH,
                height: VIEW_HEIGHT / 2,
                color: rgb(128, 128, 128),
            });

            // Main render loop
            for (let x = 0; x <= VIEW_WIDTH / 2; x++) {
                let direction = lerp(planeP1, planeP2, x / (VIEW_WIDTH / 2)).scale(6);

                const hit = rayCastAsciiGrid(this.pos, direction, grid);
                if (hit) {
                    const t = hit.t;
                    const d = (1 - t);

                    let u = Math.abs(hit.normal.x) > Math.abs(hit.normal.y)
                        ? hit.point.y
                        : hit.point.x;

                    u = (u % 16) / 16;

                    const h = VIEW_HEIGHT / (t * direction.len() / 16);

                    drawUVQuad({
                        width: 2,
                        height: h,
                        pos: vec2(x * 2, VIEW_HEIGHT / 2 - h / 2),
                        tex: wall.tex,
                        quad: slices[Math.floor(u * (wall.width - 1))],
                        color: BLACK.lerp(WHITE, d),
                    });
                }
            }

            popTransform();
        },
    },
]);

// ----------------------
// Controls
// ----------------------
onKeyDown("up", () => camera.move(Vec2.fromAngle(camera.angle).scale(40)));
onKeyDown("down", () => camera.move(Vec2.fromAngle(camera.angle).scale(-40)));
onKeyDown("left", () => camera.angle -= 90 * dt());
onKeyDown("right", () => camera.angle += 90 * dt());

</script>
</body>
</html>