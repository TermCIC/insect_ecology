<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KAPLAY 3D Example</title>
<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        gap: 12px;
        font-family: system-ui, sans-serif;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
    }

    @media (orientation: landscape) {
        #game {
            height: 70vh;
            width: auto;
        }
    }

    @media (orientation: portrait) {
        #game {
            width: 70vw;
            height: auto;
        }
    }

    canvas {
        width: 100%;
        height: 100%;
        image-rendering: pixelated;
    }

    #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    #controls .row {
        display: flex;
        gap: 4px;
    }

    #controls button {
        min-width: 200px;
        padding: 6px 10px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        cursor: pointer;
    }

    #controls button:active {
        background: #444;
    }
</style>

<script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
</head>
<body>
<div id="game"></div>
<div id="controls">
    <button id="btn-forward">↑</button>
    <div class="row">
        <button id="btn-turn-left">↺</button>
        <button id="btn-back">↓</button>
        <button id="btn-turn-right">↻</button>
    </div>
</div>

<script>
// init
kaplay({
    canvas: document.querySelector("canvas") || undefined,
    root: document.getElementById("game"),
    scale: 3,
    debug: true,
});

// sprites
loadSprite("enemy", "https://res.cloudinary.com/dmdpjf8up/image/upload/v1763978470/pixellab-monster-orc-1763978389772_tctylf.png");
loadSprite("wall", "https://res.cloudinary.com/dmdpjf8up/image/upload/v1763978431/brick_wall_2_jwuiva.png");

let enemy;
let objSlices = [];
let wall;
let slices = [];

onLoad(() => {
    enemy = getSprite("enemy").data;
    for (let i = 0; i < enemy.width; i++) {
        objSlices.push(
            enemy.frames[0].scale(
                new Quad(i / enemy.width, 0, 1 / enemy.width, 1),
            ),
        );
    }

    wall = getSprite("wall").data;
    for (let i = 0; i < wall.width; i++) {
        slices.push(
            wall.frames[0].scale(
                new Quad(i / wall.width, 0, 1 / wall.width, 1),
            ),
        );
    }
});

// ===== Raycasting helpers =====
function rayCastGrid(origin, direction, gridPosHit, maxDistance = 32) {
    const pos = origin;
    const len = direction.len();
    const dir = direction.scale(1 / len);
    let t = 0;
    let gridPos = vec2(Math.floor(origin.x), Math.floor(origin.y));
    const step = vec2(dir.x > 0 ? 1 : -1, dir.y > 0 ? 1 : -1);
    const tDelta = vec2(Math.abs(1 / dir.x), Math.abs(1 / dir.y));
    let dist = vec2(
        (step.x > 0) ? (gridPos.x + 1 - origin.x) : (origin.x - gridPos.x),
        (step.y > 0) ? (gridPos.y + 1 - origin.y) : (origin.y - gridPos.y),
    );
    let tMax = vec2(
        (tDelta.x < Infinity) ? tDelta.x * dist.x : Infinity,
        (tDelta.y < Infinity) ? tDelta.y * dist.y : Infinity,
    );
    let steppedIndex = -1;

    const h = grid.length;

    while (t <= maxDistance) {
        if (gridPos.x < 0 || gridPos.y < 0 || gridPos.y >= h || gridPos.x >= grid[gridPos.y].length) {
            break;
        }

        const hit = gridPosHit(gridPos);
        if (hit === true) {
            return {
                point: pos.add(dir.scale(t)),
                normal: vec2(
                    steppedIndex === 0 ? -step.x : 0,
                    steppedIndex === 1 ? -step.y : 0,
                ),
                t: t / len,
                gridPos,
            };
        } else if (hit) {
            return hit;
        }

        if (tMax.x < tMax.y) {
            gridPos.x += step.x;
            t = tMax.x;
            tMax.x += tDelta.x;
            steppedIndex = 0;
        } else {
            gridPos.y += step.y;
            t = tMax.y;
            tMax.y += tDelta.y;
            steppedIndex = 1;
        }
    }
    return null;
}

function raycastEdge(origin, direction, line) {
    const a = origin;
    const c = line.p1.add(line.pos);
    const d = line.p2.add(line.pos);
    const ab = direction;
    const cd = d.sub(c);
    const abxcd = ab.cross(cd);

    if (Math.abs(abxcd) < Number.EPSILON) return false;

    const ac = c.sub(a);
    const s = ac.cross(cd) / abxcd;
    if (s <= 0 || s >= 1) return false;
    const t = ac.cross(ab) / abxcd;
    if (t <= 0 || t >= 1) return false;

    const normal = cd.normal().unit();
    if (direction.dot(normal) > 0) {
        normal.x *= -1;
        normal.y *= -1;
    }

    return {
        point: a.add(ab.scale(s)),
        normal,
        t: s,
        s: t,
        object: line,
    };
}

function rayCastAsciiGrid(origin, direction, grid) {
    origin = origin.scale(1 / 16);
    direction = direction.scale(1 / 16);
    const objects = [];

    const hit = rayCastGrid(origin, direction, ({ x, y }) => {
        if (y >= 0 && y < grid.length) {
            const row = grid[y];
            if (x >= 0 && x < row.length) {

                if (row[x] === "&") {
                    const perp = direction.normal().unit();
                    const planeP1 = perp.scale(-0.2);
                    const planeP2 = perp.scale(0.2);

                    const objectHit = raycastEdge(origin, direction, {
                        pos: vec2(x + 0.5, y + 0.5),
                        p1: planeP1,
                        p2: planeP2,
                    });

                    if (objectHit) objects.push(objectHit);
                }
                return row[x] !== " " && row[x] !== "&";
            }
        }
    }, 32);

    if (hit) {
        hit.point = hit.point.scale(16);
        hit.object = { color: colors[grid[hit.gridPos.y][hit.gridPos.x]] };
        hit.objects = objects;
    }
    return hit;
}

// ===== Grid & movement =====
const colors = {
    "#": RED,
    "$": GREEN,
    "%": BLUE,
    "&": YELLOW,
};

const grid = [
    "####################################",
    "#                                  #",
    "#                                  #",
    "#   $$$$$$$$$$$$$$  $$$$$$$$$$$$   #",
    "#   $                          $   #",
    "#   $                          $   #",
    "#   $   %%%%  %%%%%%%%%%%%%%   $   #",
    "#   $   %                  %   $   #",
    "#   $   %                  %   $   #",
    "##&&$$&&%%%%%%%%%%    %%%%%%&&$$&&##",
    "#   $   %%                     $   #",
    "#   $   %%                     $   #",
    "#   $   %%%%%%%%%%%%%%%%%%%%       #",
    "#   $                          $   #",
    "#   $                          $   #",
    "#   $$$$$$$$$$$$$$  $$$$$$$$$$$$   #",
    "#                     &            #",
    "#                      &           #",
    "####################################",
];

const TILE_SIZE = 16;

// 45 degree steps (8 directions)
const TURN_STEP = 45;
const MOVE_TIME = 0.18; // time for 1-tile move in cardinal direction
const TURN_TIME = 0.12; // time for 45° turn

function canWalkToCell(gx, gy) {
    if (gy < 0 || gy >= grid.length) return false;
    const row = grid[gy];
    if (gx < 0 || gx >= row.length) return false;
    const c = row[gx];
    return c === " " || c === "&";
}

// quantize facing direction into 8 directions (45° each)
function getFacingDir() {
    let a = camera.angle;
    a = ((a % 360) + 360) % 360;
    const sector = Math.round(a / TURN_STEP) % 8;

    const dirs = [
        vec2(1, 0),    // 0°   east
        vec2(1, 1),    // 45°  south-east
        vec2(0, 1),    // 90°  south
        vec2(-1, 1),   // 135° south-west
        vec2(-1, 0),   // 180° west
        vec2(-1, -1),  // 225° north-west
        vec2(0, -1),   // 270° north
        vec2(1, -1),   // 315° north-east
    ];

    return dirs[sector];
}

function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
}

// ===== Camera entity, with manual tween in update() =====
const camera = add([
    pos(13 * TILE_SIZE + TILE_SIZE / 2, 13 * TILE_SIZE + TILE_SIZE / 2),
    rotate(0),
    z(-1),
    rect(8, 8),
    anchor("center"),
    area(),
    opacity(0),
    body(),
    {
        // movement tween state
        isMoving: false,
        moveFrom: vec2(0, 0),
        moveTo: vec2(0, 0),
        moveElapsed: 0,
        moveDuration: 1,

        // rotation tween state
        isRotating: false,
        rotFrom: 0,
        rotTo: 0,
        rotElapsed: 0,
        rotDuration: 1,

        update() {
            const d = dt();

            // position tween
            if (this.isMoving) {
                this.moveElapsed += d;
                const t = Math.min(this.moveElapsed / this.moveDuration, 1);
                this.pos = lerp(this.moveFrom, this.moveTo, t);
                if (t >= 1) {
                    this.isMoving = false;
                    this.pos = this.moveTo;
                }
            }

            // rotation tween
            if (this.isRotating) {
                this.rotElapsed += d;
                const t = Math.min(this.rotElapsed / this.rotDuration, 1);
                this.angle = this.rotFrom + (this.rotTo - this.rotFrom) * t;
                if (t >= 1) {
                    this.isRotating = false;
                    // snap to exact 45°
                    this.angle = Math.round(this.angle / TURN_STEP) * TURN_STEP;
                }
            }
        },

        draw() {
            pushTransform();
            pushRotate(-this.angle);

            const dir = Vec2.fromAngle(this.angle);
            const perp = dir.normal();

            const planeP1 = this.pos
                .add(dir.scale(this.focalLength))
                .add(perp.scale(this.fov))
                .sub(this.pos);
            const planeP2 = this.pos
                .add(dir.scale(this.focalLength))
                .sub(perp.scale(this.fov))
                .sub(this.pos);

            pushTranslate(this.pos.scale(-1).add(0, 0));

            drawRect({ width: 240, height: 120, color: rgb(50, 50, 50) });
            drawRect({ pos: vec2(0, 120), width: 240, height: 120, color: rgb(128, 128, 128) });

            for (let x = 0; x <= 120; x++) {
                const direction = lerp(planeP1, planeP2, x / 120).scale(6);

                const hit = rayCastAsciiGrid(this.pos, direction, grid);
                if (hit) {
                    const t = hit.t;
                    const d = clamp(1 - t * 1.2, 0.2, 1);

                    let u = Math.abs(hit.normal.x) > Math.abs(hit.normal.y)
                        ? hit.point.y
                        : hit.point.x;

                    u = (u % 16) / 16;
                    u = u - Math.floor(u);

                    const h = 240 / (t * direction.len() / 16);

                    drawUVQuad({
                        width: 2,
                        height: h,
                        pos: vec2(x * 2, 120 - h / 2),
                        tex: wall.tex,
                        quad: slices[Math.round(u * (wall.width - 1))],
                        color: BLACK.lerp(WHITE, d),
                    });

                    if (hit.objects) {
                        hit.objects.reverse().forEach((o) => {
                            const t2 = o.t;
                            const wh = 240 / (t2 * direction.len() / 16);
                            const oh = 180 / (t2 * direction.len() / 16);

                            const u2 = o.s;

                            drawUVQuad({
                                width: 2,
                                height: oh,
                                pos: vec2(x * 2, 120 + wh / 2 - oh),
                                tex: enemy.tex,
                                quad: objSlices[Math.round(u2 * (enemy.width - 1))],
                                color: WHITE,
                            });
                        });
                    }
                }
            }
            popTransform();
        },

        focalLength: 40,
        fov: 10,
    },
]);

addLevel(grid, {
    pos: vec2(0, 0),
    tileWidth: TILE_SIZE,
    tileHeight: TILE_SIZE,
    tiles: {
        "#": () => [rect(16, 16), color(RED), opacity(0), area(), body({ isStatic: true })],
        "$": () => [rect(16, 16), color(GREEN), opacity(0), area(), body({ isStatic: true })],
        "%": () => [rect(16, 16), color(BLUE), opacity(0), area(), body({ isStatic: true })],
        "&": () => [pos(4, 4), rect(8, 8), color(YELLOW), opacity(0)],
    },
});

// ===== movement / rotation control =====
function isBusy() {
    return camera.isMoving || camera.isRotating;
}

function startMoveStep(forward = 1) {
    if (isBusy()) return;

    const dir = getFacingDir().scale(forward);
    const stepLen = dir.len(); // 1 for cardinal, sqrt(2) for diagonal

    const gx = Math.floor(camera.pos.x / TILE_SIZE);
    const gy = Math.floor(camera.pos.y / TILE_SIZE);
    const nx = gx + dir.x;
    const ny = gy + dir.y;

    if (!canWalkToCell(nx, ny)) return;

    camera.isMoving = true;
    camera.moveElapsed = 0;
    camera.moveDuration = MOVE_TIME * stepLen;
    camera.moveFrom = vec2(camera.pos.x, camera.pos.y);
    camera.moveTo = vec2(
        (nx + 0.5) * TILE_SIZE,
        (ny + 0.5) * TILE_SIZE,
    );
}

function startTurnStep(direction) { // -1 left, +1 right
    if (isBusy()) return;

    camera.isRotating = true;
    camera.rotElapsed = 0;
    camera.rotDuration = TURN_TIME * Math.abs(direction);
    camera.rotFrom = camera.angle;
    camera.rotTo = camera.angle + direction * TURN_STEP;
}

// keyboard
onKeyPress("up", () => startMoveStep(1));
onKeyPress("down", () => startMoveStep(-1));
onKeyPress("left", () => startTurnStep(-1));
onKeyPress("right", () => startTurnStep(1));

// HTML buttons
document.getElementById("btn-forward").addEventListener("click", () => {
    startMoveStep(1);
});

document.getElementById("btn-back").addEventListener("click", () => {
    startMoveStep(-1);
});

document.getElementById("btn-turn-left").addEventListener("click", () => {
    startTurnStep(-1);
});

document.getElementById("btn-turn-right").addEventListener("click", () => {
    startTurnStep(1);
});
</script>
</body>
</html>
