<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG v0.3.7</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .hp-bar {
        font-size: 14px;
        text-align: center;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        width: 80vw;
        max-width: 480px;
    }

    @media (orientation: landscape) {
        #game {
            height: 70vh;
            width: auto;
        }
    }

    @media (orientation: portrait) {
        body {
            justify-content: flex-start;
            padding-top: 16px;
            height: auto;
        }

        #game {
            width: 95vw;
            height: 95vw;
        }

        #controls {
            width: 95vw;
            gap: 6px;
            min-height: 96px;
            margin-top: 8px;
        }

        #controls .row {
            width: 100%;
        }

        #controls button {
            flex: 1;
            min-height: 56px;
            padding: 10px 0;
            font-size: 5vw;
            box-sizing: border-box;
        }
    }

    canvas {
        width: 100%;
        height: 100%;
        image-rendering: pixelated;
    }

    #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        margin-bottom: 16px;
    }

    #controls .row {
        display: flex;
        gap: 4px;
    }

    #controls button {
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        cursor: pointer;
        min-width: 80px;
    }

    #controls button:active {
        background: #444;
    }
</style>

<script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
</head>
<body>

<div id="game-wrapper">
    <div id="monster-hp" class="hp-bar">Monster HP: -</div>
    <div id="game"></div>
    <div id="player-hp" class="hp-bar">Player HP: 100/100</div>
    <!-- DEBUG ANGLES LINE -->
    <div id="debug-angles" class="hp-bar">Cam: 0 | Fire spawn: - | Fire dir: -</div>
</div>

<div id="controls">
    <div class="row">
        <button id="btn-attack">âš”</button>
        <button id="btn-forward">â†‘</button>
        <button id="btn-potion">ðŸ§ª</button>
    </div>
    <div class="row">
        <button id="btn-turn-left">â†º</button>
        <button id="btn-back">â†“</button>
        <button id="btn-turn-right">â†»</button>
    </div>
</div>

<script>
function degToRad(a) {
    return a * Math.PI / 180;
}

function radToDeg(r) {
    return r * 180 / Math.PI;
}

const NATIVE_GAME_WIDTH = 240;
const defaultScale = 3;
let finalScale = defaultScale;
const isPortrait = window.matchMedia("(orientation: portrait)").matches;

if (isPortrait) {
    const actualGameContainerWidth = window.innerWidth;
    finalScale = actualGameContainerWidth / NATIVE_GAME_WIDTH;
}

kaplay({
    root: document.getElementById("game"),
    scale: finalScale,
    debug: true,
});

// ======== DOM UI ========
const playerHpEl  = document.getElementById("player-hp");
const monsterHpEl = document.getElementById("monster-hp");
const debugAnglesEl = document.getElementById("debug-angles");

// ======== Player & Monster stats ========
const player = {
    maxHp: 100,
    hp: 100,
    atk: 12,
};

const MONSTER_MAX_HP = 40;
const MONSTER_ATK    = 6;
const MONSTER_ATTACK_INTERVAL = 1.0;
const ATTACK_RANGE_TILES_SQ  = 3;

// fireball parameters
const FIREBALL_TILES_PER_SECOND = 1;   // speed in tiles / sec
const FIREBALL_LIFETIME         = 3;   // seconds
const FIREBALL_HIT_RADIUS       = 8;   // pixels

// list of active fireballs
const projectiles = [];

// debug vars
let lastFireSpawnAngle = null;      // camera.angle when fireball was spawned
let lastFireDirAngleDeg = null;     // atan2(dir.y, dir.x) in degrees

function radToDeg(r) {
    return r * 180 / Math.PI;
}

function updatePlayerHpUI() {
    playerHpEl.textContent = `Player HP: ${player.hp}/${player.maxHp}`;
}

function updateMonsterHpUI(target) {
    if (!target || !target.alive) {
        monsterHpEl.textContent = "Monster HP: -";
    } else {
        monsterHpEl.textContent = `Monster HP: ${target.hp}/${target.maxHp}`;
    }
}

function updateDebugAngles() {
    if (!debugAnglesEl) return;

    const camAngleDeg = camera.angle.toFixed(2);

    const fireSpawnText = (lastFireSpawnAngle !== null)
        ? lastFireSpawnAngle.toFixed(2)
        : "-";

    const fireDirText = (lastFireDirAngleDeg !== null)
        ? lastFireDirAngleDeg.toFixed(2)
        : "-";

    debugAnglesEl.textContent =
        `Cam: ${camAngleDeg} | Fire spawn: ${fireSpawnText} | Fire dir: ${fireDirText}`;
}

// ======== Sprites ========
loadSprite(
    "enemy",
    "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764057430/pixellab-jump-and-attack-toward-camera-1764054681406_zlxbfb.png",
    { sliceX: 4, sliceY: 4 },
);

loadSprite(
    "enemyIdle",
    "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764058491/pixellab-walk-and-idle-toward-camera-1764054830881_f6biy9.png",
    { sliceX: 4, sliceY: 4 },
);

loadSprite("wall_1", "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764073173/brick_wall_1_hjoaxn.png");
loadSprite("wall_2", "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764073221/brick_wall_2_ua8zgt.png");
loadSprite("wall_3", "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764057126/brick_wall_5_qtebvm.png");
loadSprite("fireball", "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764066293/fireball_mnjxyq.png");

let enemy;
let enemyIdle;
let wall_1;
let wall_2;
let wall_3;
let fireballSprite;
let fireballQuad;

// slices
let enemySlices = [];
let enemyIdleSlices = [];
let wall_1_Slices = [];
let wall_2_Slices = [];
let wall_3_Slices = [];

onLoad(() => {
    enemy        = getSprite("enemy").data;
    enemyIdle    = getSprite("enemyIdle").data;
    wall_1       = getSprite("wall_1").data;
    wall_2       = getSprite("wall_2").data;
    wall_3       = getSprite("wall_3").data;
    fireballSprite = getSprite("fireball").data;

    // full quad for fireball
    fireballQuad = fireballSprite.frames[0].scale(new Quad(0, 0, 1, 1));

    // enemy attack / walk slices
    const attackFrameWidth = enemy.width;
    const attackFrames = enemy.frames.length;
    for (let f = 0; f < attackFrames; f++) {
        const frame = enemy.frames[f];
        const cols = [];
        for (let i = 0; i < attackFrameWidth; i++) {
            cols.push(frame.scale(new Quad(i / attackFrameWidth, 0, 1 / attackFrameWidth, 1)));
        }
        enemySlices.push(cols);
    }

    // enemy idle slices
    const idleFrameWidth = enemyIdle.width;
    const idleFrames = enemyIdle.frames.length;
    for (let f = 0; f < idleFrames; f++) {
        const frame = enemyIdle.frames[f];
        const cols = [];
        for (let i = 0; i < idleFrameWidth; i++) {
            cols.push(frame.scale(new Quad(i / idleFrameWidth, 0, 1 / idleFrameWidth, 1)));
        }
        enemyIdleSlices.push(cols);
    }

    // wall slices
    for (let i = 0; i < wall_1.width; i++) {
        wall_1_Slices.push(
            wall_1.frames[0].scale(new Quad(i / wall_1.width, 0, 1 / wall_1.width, 1)),
        );
    }
    for (let i = 0; i < wall_2.width; i++) {
        wall_2_Slices.push(
            wall_2.frames[0].scale(new Quad(i / wall_2.width, 0, 1 / wall_2.width, 1)),
        );
    }
    for (let i = 0; i < wall_3.width; i++) {
        wall_3_Slices.push(
            wall_3.frames[0].scale(new Quad(i / wall_3.width, 0, 1 / wall_3.width, 1)),
        );
    }
});

// ===== Grid and raycast =====
const colors = {
    "#": RED,
    "$": GREEN,
    "%": BLUE,
    "&": YELLOW,
};

const baseGrid = [
    "##################",
    "#                #",
    "# $$$$$$$ $$$$$$ #",
    "# $            $ #",
    "# $ %% %%%%%%% $ #",
    "# $ %        % $ #",
    "#&$&%%%%%  %%%&$&#",
    "# $ %          $ #",
    "# $ %%%%%%%%%%   #",
    "# $            $ #",
    "# $$$$$$$ $$$$$$ #",
    "#          &     #",
    "##################",
];

const grid = baseGrid.map(row => row.split(""));
const TILE_SIZE = 16;

// monsters from '&' tiles
const monsters = [];
for (let y = 0; y < grid.length; y++) {
    for (let x = 0; x < grid[y].length; x++) {
        if (grid[y][x] === "&") {
            monsters.push({
                tileX: x,
                tileY: y,
                gx: x + 0.5,
                gy: y + 0.5,
                maxHp: MONSTER_MAX_HP,
                hp: MONSTER_MAX_HP,
                atk: MONSTER_ATK,
                attackTimer: 0,
                alive: true,
            });
        }
    }
}

function inBounds(gx, gy) {
    return gy >= 0 && gy < grid.length && gx >= 0 && gx < grid[gy].length;
}

function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
}

function rayCastGrid(origin, direction, gridPosHit, maxDistance = 64) {
    const pos = origin;
    const len = direction.len();
    const dir = direction.scale(1 / len);
    let t = 0;
    let gridPos = vec2(Math.floor(origin.x), Math.floor(origin.y));
    const step = vec2(dir.x > 0 ? 1 : -1, dir.y > 0 ? 1 : -1);
    const tDelta = vec2(Math.abs(1 / dir.x), Math.abs(1 / dir.y));
    let dist = vec2(
        (step.x > 0) ? (gridPos.x + 1 - origin.x) : (origin.x - gridPos.x),
        (step.y > 0) ? (gridPos.y + 1 - origin.y) : (origin.y - gridPos.y),
    );
    let tMax = vec2(
        (tDelta.x < Infinity) ? tDelta.x * dist.x : Infinity,
        (tDelta.y < Infinity) ? tDelta.y * dist.y : Infinity,
    );
    let steppedIndex = -1;

    while (t <= maxDistance) {
        if (!inBounds(gridPos.x, gridPos.y)) break;

        const hit = gridPosHit(gridPos);
        if (hit === true) {
            return {
                point: pos.add(dir.scale(t)),
                normal: vec2(
                    steppedIndex === 0 ? -step.x : 0,
                    steppedIndex === 1 ? -step.y : 0,
                ),
                t: t / len,
                gridPos,
            };
        } else if (hit) {
            return hit;
        }

        if (tMax.x < tMax.y) {
            gridPos.x += step.x;
            t = tMax.x;
            tMax.x += tDelta.x;
            steppedIndex = 0;
        } else {
            gridPos.y += step.y;
            t = tMax.y;
            tMax.y += tDelta.y;
            steppedIndex = 1;
        }
    }
    return null;
}

function raycastEdge(origin, direction, line) {
    const a = origin;
    const c = line.p1.add(line.pos);
    const d = line.p2.add(line.pos);
    const ab = direction;
    const cd = d.sub(c);
    const abxcd = ab.cross(cd);

    if (Math.abs(abxcd) < Number.EPSILON) return false;

    const ac = c.sub(a);
    const s = ac.cross(cd) / abxcd;
    if (s <= 0 || s >= 1) return false;
    const t = ac.cross(ab) / abxcd;
    if (t <= 0 || t >= 1) return false;

    const normal = cd.normal().unit();
    if (direction.dot(normal) > 0) {
        normal.x *= -1;
        normal.y *= -1;
    }

    return {
        point: a.add(ab.scale(s)),
        normal,
        t: s,
        s: t,
        object: line,
    };
}

function rayCastAsciiGrid(origin, direction) {
    origin = origin.scale(1 / 16);
    direction = direction.scale(1 / 16);
    const objects = [];

    const hit = rayCastGrid(origin, direction, ({ x, y }) => {
        if (y >= 0 && y < grid.length) {
            const row = grid[y];
            if (x >= 0 && x < row.length) {
                const tile = row[x];

                if (tile === "&") {
                    const monster = monsters.find(m => m.tileX === x && m.tileY === y && m.alive);
                    if (!monster) return false;

                    const perp = direction.normal().unit();
                    const planeP1 = perp.scale(-0.2);
                    const planeP2 = perp.scale(0.2);

                    const line = {
                        pos: vec2(x + 0.5, y + 0.5),
                        p1: planeP1,
                        p2: planeP2,
                        monster: monster,
                    };

                    const objectHit = raycastEdge(origin, direction, line);
                    if (objectHit) objects.push(objectHit);
                    return false; // '&' not a wall
                }
                return tile !== " " && tile !== "&";
            }
        }
    }, direction.len());

    if (hit) {
        hit.point = hit.point.scale(16);
        hit.object = { color: colors[grid[hit.gridPos.y][hit.gridPos.x]] };
        hit.objects = objects;
    }
    return hit;
}

// ===== Camera entity (draw only) =====
const startGX = 8;
const startGY = 9;

let animTime = 0;

const camera = add([
    pos((startGX + 0.5) * TILE_SIZE, (startGY + 0.5) * TILE_SIZE),
    rotate(0),
    z(-1),
    rect(8, 8),
    anchor("center"),
    area(),
    opacity(0),
    body(),
    {
        focalLength: 40,
        fov: 10,

        draw() {
            pushTransform();
            pushRotate(-this.angle);

            const angleRad = degToRad(this.angle);     // convert to radians for trig
            const dir = Vec2.fromAngle(angleRad);
            const perp = dir.normal();

            const planeP1 = this.pos
                .add(dir.scale(this.focalLength))
                .add(perp.scale(this.fov))
                .sub(this.pos);
            const planeP2 = this.pos
                .add(dir.scale(this.focalLength))
                .sub(perp.scale(this.fov))
                .sub(this.pos);

            pushTranslate(this.pos.scale(-1).add(0, 0));

            drawRect({ width: 240, height: 120, color: rgb(50, 50, 50) });
            drawRect({ pos: vec2(0, 120), width: 240, height: 120, color: rgb(128, 128, 128) });

            // current frames for attack and idle
            let currentAttackSlices = null;
            let currentIdleSlices = null;

            if (enemySlices.length > 0) {
                const attackSpeed = 12;
                const attackIndex = Math.floor(animTime * attackSpeed) % enemySlices.length;
                currentAttackSlices = enemySlices[attackIndex];
            }

            if (enemyIdleSlices.length > 0) {
                const idleSpeed = 6;
                const idleIndex = Math.floor(animTime * idleSpeed) % enemyIdleSlices.length;
                currentIdleSlices = enemyIdleSlices[idleIndex];
            }

            const playerGX = this.pos.x / TILE_SIZE;
            const playerGY = this.pos.y / TILE_SIZE;

            for (let x = 0; x <= 120; x++) {
                const direction = lerp(planeP1, planeP2, x / 120).scale(6);
                const hit = rayCastAsciiGrid(this.pos, direction);

                if (hit) {
                    const t = hit.t;
                    const d = clamp(1 - t * 1.2, 0.2, 1);

                    let u = Math.abs(hit.normal.x) > Math.abs(hit.normal.y)
                        ? hit.point.y
                        : hit.point.x;
                    u = (u % 16) / 16;
                    u = u - Math.floor(u);

                    const h = 240 / (t * direction.len() / 16);

                    const tileChar = grid[hit.gridPos.y][hit.gridPos.x];
                    let wallTex;
                    let wallSlicesArr;

                    if (tileChar === "#") {
                        wallTex = wall_1 ? wall_1.tex : null;
                        wallSlicesArr = wall_1_Slices;
                    } else if (tileChar === "$") {
                        wallTex = wall_2 ? wall_2.tex : null;
                        wallSlicesArr = wall_2_Slices;
                    } else if (tileChar === "%") {
                        wallTex = wall_3 ? wall_3.tex : null;
                        wallSlicesArr = wall_3_Slices;
                    } else {
                        wallTex = wall_1 ? wall_1.tex : null;
                        wallSlicesArr = wall_1_Slices;
                    }

                    const sliceIdx = wallSlicesArr.length > 0
                        ? Math.round(u * (wallSlicesArr.length - 1))
                        : 0;

                    drawUVQuad({
                        width: 2,
                        height: h,
                        pos: vec2(x * 2, 120 - h / 2),
                        tex: wallTex,
                        quad: wallSlicesArr[sliceIdx],
                        color: BLACK.lerp(WHITE, d),
                    });

                    // animated monsters
                    if (hit.objects && currentAttackSlices && currentIdleSlices) {
                        hit.objects.slice().reverse().forEach((o) => {
                            const monster = o.object.monster;
                            if (!monster || !monster.alive) return;

                            const t2 = o.t;
                            const wh = 240 / (t2 * direction.len() / 16);
                            const oh = 180 / (t2 * direction.len() / 16);

                            const u2 = o.s;

                            const dx = monster.gx - playerGX;
                            const dy = monster.gy - playerGY;
                            const distSq = dx * dx + dy * dy;

                            const useIdle = distSq > ATTACK_RANGE_TILES_SQ;

                            const slices = useIdle ? currentIdleSlices : currentAttackSlices;
                            const tex = useIdle ? enemyIdle.tex : enemy.tex;

                            const sliceIndex = Math.round(
                                u2 * (slices.length - 1),
                            );

                            drawUVQuad({
                                width: 2,
                                height: oh,
                                pos: vec2(x * 2, 120 + wh / 2 - oh),
                                tex: tex,
                                quad: slices[sliceIndex],
                                color: WHITE,
                            });
                        });
                    }
                }
            }
            popTransform();

            // ===== draw fireballs using same FOV as raycaster =====
            if (fireballSprite && fireballQuad) {
                const halfFovRad = Math.atan(this.fov / this.focalLength);
                const FOV = halfFovRad * 2;
                const NUM_RAYS = 120;
                const DELTA_ANGLE = FOV / NUM_RAYS;
                const CENTER_RAY = NUM_RAYS / 2;
            
                // use same angleRad as above
                const viewAngle = angleRad;
            
                for (const fb of projectiles) {
                    const rel = fb.pos.sub(this.pos);
                    const distance = rel.len();
                    if (distance < 1) continue;
            
                    const theta = Math.atan2(rel.y, rel.x);
                    let gamma = theta - viewAngle;
            
                    while (gamma < -Math.PI) gamma += 2 * Math.PI;
                    while (gamma >  Math.PI) gamma -= 2 * Math.PI;
            
                    if (Math.abs(gamma) > halfFovRad) continue;
            
                    const rayOffset = gamma / DELTA_ANGLE;
                    const currentRay = CENTER_RAY + rayOffset;
                    if (currentRay < 0 || currentRay > NUM_RAYS) continue;
            
                    const screenX = currentRay * 2;
            
                    const distCorrected = distance * Math.cos(gamma);
                    const distTiles = distCorrected / TILE_SIZE;
            
                    const spriteH = 120 / distTiles;
                    const spriteW = spriteH;
            
                    const bottomY = 220;
                    const centerY = bottomY - spriteH / 2;
            
                    drawUVQuad({
                        width: spriteW,
                        height: spriteH,
                        pos: vec2(screenX - spriteW / 2, centerY - spriteH / 2),
                        tex: fireballSprite.tex,
                        quad: fireballQuad,
                        color: WHITE,
                    });
                }
            }
        },
    },
]);

// level collisions
addLevel(baseGrid, {
    pos: vec2(0, 0),
    tileWidth: TILE_SIZE,
    tileHeight: TILE_SIZE,
    tiles: {
        "#": () => [rect(16, 16), color(RED), area(), body({ isStatic: true }), opacity(0)],
        "$": () => [rect(16, 16), color(GREEN), area(), body({ isStatic: true }), opacity(0)],
        "%": () => [rect(16, 16), color(BLUE), area(), body({ isStatic: true }), opacity(0)],
        "&": () => [pos(4, 4), rect(8, 8), color(YELLOW), opacity(0)],
    },
});

const STEP_DIST = 40;
const ROT_SPEED = 90;

onKeyDown("up", () => {
    camera.move(Vec2.fromAngle(camera.angle).scale(STEP_DIST));
});
onKeyDown("down", () => {
    camera.move(Vec2.fromAngle(camera.angle).scale(-STEP_DIST));
});
onKeyDown("left", () => {
    camera.angle -= ROT_SPEED * dt();
});
onKeyDown("right", () => {
    camera.angle += ROT_SPEED * dt();
});

// ===== fireball spawn & potion =====
function spawnFireball() {
    lastFireSpawnAngle = camera.angle;

    const dir = Vec2.fromAngle(camera.angle).unit();
    const start = vec2(camera.pos.x, camera.pos.y).add(dir.scale(10));

    // real direction angle from velocity vector
    lastFireDirAngleDeg = radToDeg(Math.atan2(dir.y, dir.x));

    projectiles.push({
        pos: start,
        dir: dir,
        life: FIREBALL_LIFETIME,
    });
}

function playerAttack() {
    spawnFireball();
}

function drinkPotion() {
    player.hp = Math.min(player.maxHp, player.hp + 25);
    updatePlayerHpUI();
}

// ===== HTML buttons =====
let btnForwardHeld   = false;
let btnBackHeld      = false;
let btnTurnLeftHeld  = false;
let btnTurnRightHeld = false;

function bindHoldButton(id, setter) {
    const btn = document.getElementById(id);
    btn.addEventListener("mousedown", () => setter(true));
    btn.addEventListener("mouseup",   () => setter(false));
    btn.addEventListener("mouseleave",() => setter(false));
    btn.addEventListener("touchstart", e => { e.preventDefault(); setter(true); });
    btn.addEventListener("touchend",   e => { e.preventDefault(); setter(false); });
}

bindHoldButton("btn-forward",    v => btnForwardHeld = v);
bindHoldButton("btn-back",       v => btnBackHeld = v);
bindHoldButton("btn-turn-left",  v => btnTurnLeftHeld = v);
bindHoldButton("btn-turn-right", v => btnTurnRightHeld = v);

document.getElementById("btn-attack").addEventListener("click", playerAttack);
document.getElementById("btn-potion").addEventListener("click", drinkPotion);

onKeyPress("space", playerAttack);
onKeyPress("h", drinkPotion);

// ===== global update =====
let currentTarget = null;

onUpdate(() => {
    const d = dt();
    animTime += d;

    // movement (button hold)
    if (btnForwardHeld) {
        camera.move(Vec2.fromAngle(camera.angle).scale(STEP_DIST));
    }
    if (btnBackHeld) {
        camera.move(Vec2.fromAngle(camera.angle).scale(-STEP_DIST));
    }
    if (btnTurnLeftHeld) {
        camera.angle -= ROT_SPEED * d;
    }
    if (btnTurnRightHeld) {
        camera.angle += ROT_SPEED * d;
    }

    // update fireballs (movement + collision)
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const fb = projectiles[i];
        fb.life -= d;
        if (fb.life <= 0) {
            projectiles.splice(i, 1);
            continue;
        }

        const speedPxPerSec = FIREBALL_TILES_PER_SECOND * TILE_SIZE;
        fb.pos = fb.pos.add(fb.dir.scale(speedPxPerSec * d));

        // out of bounds or hit wall
        const gx = Math.floor(fb.pos.x / TILE_SIZE);
        const gy = Math.floor(fb.pos.y / TILE_SIZE);
        if (!inBounds(gx, gy)) {
            projectiles.splice(i, 1);
            continue;
        }
        const tile = grid[gy][gx];
        if (tile !== " " && tile !== "&") {
            projectiles.splice(i, 1);
            continue;
        }

        // hit monster
        let hit = false;
        for (const m of monsters) {
            if (!m.alive) continue;
            const mx = m.gx * TILE_SIZE;
            const my = m.gy * TILE_SIZE;
            const dx = mx - fb.pos.x;
            const dy = my - fb.pos.y;
            if (dx * dx + dy * dy <= FIREBALL_HIT_RADIUS * FIREBALL_HIT_RADIUS) {
                m.hp = Math.max(0, m.hp - player.atk);
                if (m.hp <= 0) {
                    m.alive = false;
                    grid[m.tileY][m.tileX] = " ";
                }
                hit = true;
                break;
            }
        }
        if (hit) {
            projectiles.splice(i, 1);
        }
    }

    // monster auto-attack when in range
    const playerGX = camera.pos.x / TILE_SIZE;
    const playerGY = camera.pos.y / TILE_SIZE;

    currentTarget = null;
    let nearestDistSq = Infinity;

    for (const m of monsters) {
        if (!m.alive) continue;
        const dx = m.gx - playerGX;
        const dy = m.gy - playerGY;
        const distSq = dx * dx + dy * dy;

        if (distSq < nearestDistSq) {
            nearestDistSq = distSq;
            currentTarget = m;
        }

        if (distSq <= ATTACK_RANGE_TILES_SQ) {
            m.attackTimer -= d;
            if (m.attackTimer <= 0) {
                player.hp = Math.max(0, player.hp - m.atk);
                m.attackTimer = MONSTER_ATTACK_INTERVAL;
                updatePlayerHpUI();
            }
        }
    }

    updateMonsterHpUI(currentTarget);
    updateDebugAngles();

    if (player.hp <= 0) {
        player.hp = 0;
        updatePlayerHpUI();
    }
});

// init UI
updatePlayerHpUI();
updateMonsterHpUI(null);
updateDebugAngles();
</script>

</body>
</html>
