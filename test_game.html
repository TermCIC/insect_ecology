<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG v0.3.0</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .hp-bar {
        font-size: 14px;
        text-align: center;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        width: 80vw;
        max-width: 480px;
    }

    #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        margin-bottom: 16px;
    }

    #controls .row {
        display: flex;
        gap: 4px;
    }

    #controls button {
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        cursor: pointer;
        min-width: 80px;
    }

    #controls button:active {
        background: #444;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>

<div id="game-wrapper">
    <div id="game">
        <canvas id="renderCanvas"></canvas>
    </div>
    <div id="player-hp" class="hp-bar">Player HP: 100/100</div>
    <div id="debug-angles" class="hp-bar">Cam: 0 | Fire spawn: - | Fire dir: -</div>
</div>

<div id="controls">
    <div class="row">
        <button id="btn-attack">‚öî</button>
        <button id="btn-forward">‚Üë</button>
        <button id="btn-potion">üß™</button>
    </div>
    <div class="row">
        <button id="btn-turn-left">‚Ü∫</button>
        <button id="btn-back">‚Üì</button>
        <button id="btn-turn-right">‚Üª</button>
    </div>
</div>

<script>
// ===== Helpers =====
function normDeg(a) {
    a = a % 360;
    if (a < 0) a += 360;
    return a;
}

// ===== DOM =====
const playerHpEl = document.getElementById("player-hp");
const debugAnglesEl = document.getElementById("debug-angles");

// ===== States =====
const player = { maxHp: 100, hp: 100, atk: 12 };

const ATTACK_RANGE = 3.0;
const FIREBALL_SPEED = 12;
const FIREBALL_RADIUS = 0.4;
const FIREBALL_LIFETIME = 3;

let lastFireSpawnAngleDeg = null;
let lastFireDirAngleDeg = null;

// ===== BabylonJS =====
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let scene, camera, playerLight;
const projectiles = [];

// Torch flicker
let torchTime = 0;
const BASE_TORCH_INTENSITY = 1.25;

// ===== Background music =====
const bgm = new Audio(
    "https://res.cloudinary.com/dmdpjf8up/video/upload/v1764212100/Shadows_Whisper_ochrfz.mp3"
);
bgm.loop = true;
bgm.volume = 0.03; // 0 - 1

// ===== Footstep sound (looping while moving) =====
const footstepLoop = new Audio(
    "https://res.cloudinary.com/dmdpjf8up/video/upload/v1764211209/step_out_2_out_ajknof.mp3"
);
footstepLoop.volume = 0.95;
footstepLoop.loop = true;  // browser will loop it once it reaches the end

// Track if we want footsteps this frame
let wantFootsteps = false;

// Map and geometry constants
const MAP_SIZE = 30;
const TILE_SIZE = 2;
const HALF_MAP = MAP_SIZE / 2;

const FLOOR_THICKNESS = 0.2;
const WALL_HEIGHT = 3.0;
const CEILING_THICKNESS = 0.2;
const CEILING_Y = WALL_HEIGHT;

const CAMERA_HEIGHT = 1.4;
const PLAYER_RADIUS = 0.75;

// ===== Maps =====
const groundMap = [
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
];

const wallMap = [
  "##############################", // 0
  "#............#.##............#", // 1
  "#............#..#............#", // 2
  "#............#..#............#", // 3
  "#............#..#............#", // 4
  "#............##.#............#", // 5
  "#............................#", // 6
  "#..###.##..........######....#", // 7
  "#..#....#...............#....#", // 8
  "#..#....#....#.....#....#....#", // 9
  "#..#....#....###...#....#....#", // 10
  "#..####.#..........###.##....#", // 11
  "#............................#", // 12
  "#............####............#", // 13
  "#............#..#............#", // 14
  "#............#..#............#", // 15
  "#............#...............#", // 16
  "#............####............#", // 17
  "#............................#", // 18
  "#....#########....######.##..#", // 19
  "#....#.......#....#.......#..#", // 20
  "#....#.......#....#.......#..#", // 21
  "#....#####.###....#########..#", // 22
  "#............................#", // 23
  "#............................#", // 24
  "#............................#", // 25
  "#............................#", // 26
  "#............................#", // 27
  "#............................#", // 28
  "##############################", // 29
];

const ceilingMap = groundMap;

const objectMap = [
  "..............................", // 0
  "..............................", // 1
  "..............................", // 2
  "..............................", // 3
  "..............................", // 4
  "..............................", // 5
  "...........M..................", // 6
  "..............................", // 7
  "..............................", // 8
  "..............................", // 9
  "..............................", // 10
  ".....................M........", // 11
  "..............................", // 12
  "..............................", // 13
  "...............M..............", // 14
  "..............................", // 15
  "..............................", // 16
  "..............................", // 17
  "..............................", // 18
  "..............................", // 19
  "..............................", // 20
  "..............................", // 21
  "..............................", // 22
  "..............................", // 23
  "...............P..............", // 24
  "..............................", // 25
  "..............................", // 26
  "..............................", // 27
  "..............................", // 28
  "..............................", // 29
];

function gridToWorld(i, j) {
    const x = (j - HALF_MAP + 0.5) * TILE_SIZE;
    const z = (i - HALF_MAP + 0.5) * TILE_SIZE;
    return new BABYLON.Vector3(x, 0, z);
}

function worldToGrid(x, z) {
    const j = Math.floor(x / TILE_SIZE + HALF_MAP);
    const i = Math.floor(z / TILE_SIZE + HALF_MAP);
    return { i, j };
}

// =====================
// 2D Sprite Monster System
// =====================

// Â≠òÊâÄÊúâÊÄ™Áâ©
const monsters = [];

// ÊÄ™Áâ©ÂèÉÊï∏
const MONSTER_MAX_HP = 40;
const MONSTER_SCALE = 2.2;  // Á≤æÈùàÂ§ßÂ∞è
const MONSTER_TEXTURE = "https://res.cloudinary.com/dmdpjf8up/image/upload/v1763977803/enemy_3_olbbj7.png";

// Âª∫Á´ã‰∏ÄÈöªÁ¥ôÁâáÊÄ™Áâ©
function createMonster(scene, worldPos) {
    const plane = BABYLON.MeshBuilder.CreatePlane("monster", {
        size: MONSTER_SCALE,
    }, scene);

    plane.position = new BABYLON.Vector3(worldPos.x, 1.1, worldPos.z);
    plane.billboardMode = BABYLON.TransformNode.BILLBOARDMODE_NONE;

    const mat = new BABYLON.StandardMaterial("monsterMat", scene);
    mat.diffuseTexture = new BABYLON.Texture(MONSTER_TEXTURE, scene);
    mat.diffuseTexture.hasAlpha = true;
    mat.backFaceCulling = false;
    mat.useAlphaFromDiffuseTexture = true;
    mat.disableLighting = false;
    mat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    plane.material = mat;

    return {
        mesh: plane,
        hp: MONSTER_MAX_HP,
        maxHp: MONSTER_MAX_HP,
        alive: true,
        cooldown: 0,
    };
}

// ÊéÉÊèè objectMap Êâæ M ‚Üí ÁîüÊàêÊÄ™Áâ©
function spawnMonsters(scene) {
    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            if (objectMap[i][j] === "M") {
                const pos = gridToWorld(i, j);
                const monster = createMonster(scene, pos);
                monsters.push(monster);
            }
        }
    }
}

document.getElementById("btn-attack").onclick = () => {
    for (const m of monsters) {
        if (!m.alive) continue;

        const dx = camera.position.x - m.mesh.position.x;
        const dz = camera.position.z - m.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        // ÊîªÊìäË∑ùÈõ¢ 2.2 ÂÖ¨Â∞∫
        if (dist < 2.2) {
            m.hp -= 12;

            if (m.hp <= 0) {
                m.alive = false;
                m.mesh.dispose(); // ÁßªÈô§ÊÄ™Áâ©Ê®°Âûã
            }
        }
    }
};
    
function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.collisionsEnabled = false;

    // Camera
    camera = new BABYLON.UniversalCamera(
        "playerCamera",
        new BABYLON.Vector3(0, CAMERA_HEIGHT, -8),
        scene
    );
    camera.inertia = 0;
    camera.checkCollisions = false;
    camera.minZ = 0.01;

    // Ambient light
    const hemi = new BABYLON.HemisphericLight(
        "hemi",
        new BABYLON.Vector3(0, 1, 0),
        scene
    );
    hemi.intensity = 0.1;

    // Player torch
    playerLight = new BABYLON.PointLight(
        "playerTorch",
        new BABYLON.Vector3(0.4, 0.4, 1.0),
        scene
    );
    playerLight.parent = camera;
    playerLight.range = 10.5;
    playerLight.intensity = BASE_TORCH_INTENSITY;
    playerLight.diffuse  = new BABYLON.Color3(1.0, 0.82, 0.62);
    playerLight.specular = new BABYLON.Color3(0.25, 0.18, 0.12);
    playerLight.falloffType = BABYLON.Light.FALLOFF_STANDARD;

    // Textures
    const wallTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764201544/dark_stone_wall_3_bclnch.png",
        scene
    );
    const floorTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764202147/dark_stone_floor_2_km9hfy.png",
        scene
    );
    const ceilTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764147143/dark_stone_ceil_wepupg.png",
        scene
    );

    const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
    wallMat.diffuseTexture = wallTexture;
    wallMat.specularColor = new BABYLON.Color3(0.1, 0.08, 0.06);

    const floorMat = new BABYLON.StandardMaterial("floorMat", scene);
    floorMat.diffuseTexture = floorTexture;
    floorMat.specularColor = new BABYLON.Color3(0.08, 0.07, 0.05);

    const ceilMat = new BABYLON.StandardMaterial("ceilMat", scene);
    ceilMat.diffuseTexture = ceilTexture;
    ceilMat.specularColor = new BABYLON.Color3(0.08, 0.07, 0.05);

    const wallBoxOptions = {
        width: TILE_SIZE,
        depth: TILE_SIZE,
        height: WALL_HEIGHT,
        wrap: true
    };

    const floorBoxOptions = {
        width: TILE_SIZE,
        depth: TILE_SIZE,
        height: FLOOR_THICKNESS
    };

    const ceilBoxOptions = {
        width: TILE_SIZE,
        depth: TILE_SIZE,
        height: CEILING_THICKNESS
    };

    let playerSpawn = null;

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const pos = gridToWorld(i, j);

            if (groundMap[i][j] === "#") {
                const floor = BABYLON.MeshBuilder.CreateBox(
                    `floor_${i}_${j}`,
                    floorBoxOptions,
                    scene
                );
                floor.position = new BABYLON.Vector3(
                    pos.x,
                    -FLOOR_THICKNESS / 2,
                    pos.z
                );
                floor.material = floorMat;
            }

            if (wallMap[i][j] === "#") {
                const wall = BABYLON.MeshBuilder.CreateBox(
                    `wall_${i}_${j}`,
                    wallBoxOptions,
                    scene
                );
                wall.position = new BABYLON.Vector3(
                    pos.x,
                    WALL_HEIGHT / 2,
                    pos.z
                );
                wall.material = wallMat;
            }

            if (ceilingMap[i][j] === "#") {
                const ceil = BABYLON.MeshBuilder.CreateBox(
                    `ceil_${i}_${j}`,
                    ceilBoxOptions,
                    scene
                );
                ceil.position = new BABYLON.Vector3(
                    pos.x,
                    CEILING_Y + CEILING_THICKNESS / 2,
                    pos.z
                );
                ceil.material = ceilMat;
            }

            if (objectMap[i][j] === "P") {
                playerSpawn = new BABYLON.Vector3(pos.x, CAMERA_HEIGHT, pos.z);
            }
        }
    }

    if (playerSpawn) {
        camera.position = playerSpawn.clone();
    }

    return scene;
}

scene = createScene();
spawnMonsters(scene);
    
// ===== Movement & Collision =====
const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

function isCircleCollidingWithWalls(pos) {
    const grid = worldToGrid(pos.x, pos.z);
    if (grid.i < 0 || grid.i >= MAP_SIZE || grid.j < 0 || grid.j >= MAP_SIZE) {
        return true;
    }

    for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
            const wi = grid.i + di;
            const wj = grid.j + dj;

            if (wi < 0 || wi >= MAP_SIZE || wj < 0 || wj >= MAP_SIZE) {
                continue;
            }
            if (wallMap[wi][wj] !== "#") continue;

            const xMin = (wj - HALF_MAP) * TILE_SIZE;
            const xMax = xMin + TILE_SIZE;
            const zMin = (wi - HALF_MAP) * TILE_SIZE;
            const zMax = zMin + TILE_SIZE;

            const cx = Math.max(xMin, Math.min(pos.x, xMax));
            const cz = Math.max(zMin, Math.min(pos.z, zMax));

            const dx = pos.x - cx;
            const dz = pos.z - cz;
            if (dx * dx + dz * dz < PLAYER_RADIUS * PLAYER_RADIUS) {
                return true;
            }
        }
    }
    return false;
}
    
function tryMove(stepVec) {
    let didMove = false;
    // X-axis attempt
    const posX = camera.position.add(new BABYLON.Vector3(stepVec.x, 0, 0));
    if (!isCircleCollidingWithWalls(posX)) {
        camera.position.x = posX.x;
        didMove = true;
    }

    // Z-axis attempt
    const posZ = camera.position.add(new BABYLON.Vector3(0, 0, stepVec.z));
    if (!isCircleCollidingWithWalls(posZ)) {
        camera.position.z = posZ.z;
        didMove = true;
    }
    return didMove;
}


// ===== Input =====
let btnForwardHeld = false,
    btnBackHeld = false,
    btnTurnLeftHeld = false,
    btnTurnRightHeld = false;

const keys = { forward: false, back: false, left: false, right: false };

function bindHoldButton(id, setter) {
    const btn = document.getElementById(id);
    if (!btn) return;
    btn.addEventListener("mousedown", () => setter(true));
    btn.addEventListener("mouseup", () => setter(false));
    btn.addEventListener("mouseleave", () => setter(false));
    btn.addEventListener("touchstart", e => { e.preventDefault(); setter(true); });
    btn.addEventListener("touchend", e => { e.preventDefault(); setter(false); });
}

bindHoldButton("btn-forward", v => (btnForwardHeld = v));
bindHoldButton("btn-back", v => (btnBackHeld = v));
bindHoldButton("btn-turn-left", v => (btnTurnLeftHeld = v));
bindHoldButton("btn-turn-right", v => (btnTurnRightHeld = v));

window.addEventListener("keydown", e => {
    if (e.key === "w" || e.key === "ArrowUp") keys.forward = true;
    if (e.key === "s" || e.key === "ArrowDown") keys.back = true;
    if (e.key === "a" || e.key === "ArrowLeft") keys.left = true;
    if (e.key === "d" || e.key === "ArrowRight") keys.right = true;
});

window.addEventListener("keyup", e => {
    if (e.key === "w" || e.key === "ArrowUp") keys.forward = false;
    if (e.key === "s" || e.key === "ArrowDown") keys.back = false;
    if (e.key === "a" || e.key === "ArrowLeft") keys.left = false;
    if (e.key === "d" || e.key === "ArrowRight") keys.right = false;
});

// ===== Game loop =====
function update(dt) {
    // rotation
    if (btnTurnLeftHeld || keys.left) {
        camera.rotation.y -= TURN_SPEED * dt;
    }
    if (btnTurnRightHeld || keys.right) {
        camera.rotation.y += TURN_SPEED * dt;
    }

    // movement
    const forward = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
    const flat = new BABYLON.Vector3(forward.x, 0, forward.z).normalize();
    const step = MOVE_SPEED * dt;

    let moved = false;

    if (btnForwardHeld || keys.forward) {
        if (tryMove(flat.scale(step))) moved = true;
    }
    if (btnBackHeld || keys.back) {
        if (tryMove(flat.scale(-step))) moved = true;
    }

    // footsteps: keep a looping sound while moving
    wantFootsteps = moved;
    if (wantFootsteps) {
        if (footstepLoop.paused) {
            footstepLoop.play().catch(() => {});
        }
    } else {
        if (!footstepLoop.paused) {
            footstepLoop.pause();
            // optional: do not reset currentTime so resume feels natural
            // footstepLoop.currentTime = 0; // uncomment if you prefer reset
        }
    }

    // torch flicker
    torchTime += dt;
    const flicker =
        Math.sin(torchTime * 6.3) * 0.08 +
        Math.sin(torchTime * 11.1) * 0.05 +
        (Math.random() - 0.5) * 0.02;

    let intensity = BASE_TORCH_INTENSITY + flicker;
    intensity = Math.min(1.6, Math.max(0.95, intensity));
    playerLight.intensity = intensity;

    // =====================
    // Monster AI Update
    // =====================
    for (const m of monsters) {
        if (!m.alive) continue;
    
        const dx = camera.position.x - m.mesh.position.x;
        const dz = camera.position.z - m.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        const angle = Math.atan2(dx, dz); // face toward camera horizontally only

        // Rotate monster around Y only
        m.mesh.rotation.y = angle;
        
        // Á∞°ÊòìËøΩËπ§ (ËøëÊâçÈñãÂßãËµ∞)
        if (dist < 8 && dist > 1.5) {
            const spd = 1.4 * dt;
            m.mesh.position.x += (dx / dist) * spd;
            m.mesh.position.z += (dz / dist) * spd;
        }
    
        // ÊîªÊìäÁé©ÂÆ∂
        if (dist < 1.5) {
            if (m.cooldown <= 0) {
                player.hp -= 4;
                m.cooldown = 1.2; // CD
            }
        }
    
        if (m.cooldown > 0) m.cooldown -= dt;
    }
    
    // Êõ¥Êñ∞Áé©ÂÆ∂ HP È°ØÁ§∫
    playerHpEl.textContent = `Player HP: ${player.hp}/${player.maxHp}`;

}

engine.runRenderLoop(() => {
    const dt = engine.getDeltaTime() / 1000;
    update(dt);
    scene.render();
    // background music autoplay attempt
    bgm.play().catch(() => {
        console.log("BGM will start on first user input.");
    });
});

window.addEventListener("resize", () => engine.resize());
window.addEventListener("click", () => {
    if (bgm.paused) bgm.play().catch(() => {});
});

</script>

</body>
</html>
