<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG v0.1.4</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .hp-bar {
        font-size: 14px;
        text-align: center;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        width: 80vw;
        max-width: 480px;
    }

    #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        margin-bottom: 16px;
    }

    #controls .row {
        display: flex;
        gap: 4px;
    }

    #controls button {
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        cursor: pointer;
        min-width: 80px;
    }

    #controls button:active {
        background: #444;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<!-- Needed for GLB / GLTF / OBJ etc -->
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>

<div id="game-wrapper">
    <div id="monster-hp" class="hp-bar">Monster HP: -</div>
    <div id="game">
        <canvas id="renderCanvas"></canvas>
    </div>
    <div id="player-hp" class="hp-bar">Player HP: 100/100</div>
    <div id="debug-angles" class="hp-bar">Cam: 0 | Fire spawn: - | Fire dir: -</div>
</div>

<div id="controls">
    <div class="row">
        <button id="btn-attack">âš”</button>
        <button id="btn-forward">â†‘</button>
        <button id="btn-potion">ðŸ§ª</button>
    </div>
    <div class="row">
        <button id="btn-turn-left">â†º</button>
        <button id="btn-back">â†“</button>
        <button id="btn-turn-right">â†»</button>
    </div>
</div>

<script>
// ===== Helpers =====
function normDeg(a) {
    a = a % 360;
    if (a < 0) a += 360;
    return a;
}

// ===== DOM =====
const playerHpEl = document.getElementById("player-hp");
const monsterHpEl = document.getElementById("monster-hp");
const debugAnglesEl = document.getElementById("debug-angles");

// ===== States =====
const player = { maxHp: 100, hp: 100, atk: 12 };
const monsterState = { maxHp: 40, hp: 40, atk: 6, alive: true, cooldown: 0 };

const ATTACK_RANGE = 3.0;
const FIREBALL_SPEED = 12;
const FIREBALL_RADIUS = 0.4;
const FIREBALL_LIFETIME = 3;

let lastFireSpawnAngleDeg = null;
let lastFireDirAngleDeg = null;

// ===== BabylonJS =====
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let scene, camera, monsterMesh, playerLight;
const projectiles = [];

// Torch flicker
let torchTime = 0;
const BASE_TORCH_INTENSITY = 1.15;

// Map and geometry constants
const MAP_SIZE = 10;
const TILE_SIZE = 2;
const HALF_MAP = MAP_SIZE / 2;

const FLOOR_THICKNESS = 0.2;
const WALL_HEIGHT = 3.0;
const CEILING_THICKNESS = 0.2;
const CEILING_Y = WALL_HEIGHT;

const CAMERA_HEIGHT = 1.4;
const PLAYER_RADIUS = 0.75;

// ===== Enemy asset URLs =====
// Put your own URLs here
const MONSTER_MODEL_ROOT = "https://res.cloudinary.com/dmdpjf8up/image/upload/";   // example root
const MONSTER_MODEL_FILE = "v1764148914/7931623c-4ef3-4e2f-8545-ee10d2ead6c9_sj2w6k.glb";                               // example file
const MONSTER_TEXTURE_URL = ""; // optional: leave empty to use model's own material

// ===== Maps =====
const groundMap = [
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
];

const wallMap = [
    "##########",
    "#........#",
    "#...#....#",
    "#........#",
    "#........#",
    "#..###...#",
    "#........#",
    "#........#",
    "#........#",
    "##########",
];

const ceilingMap = groundMap;

const objectMap = [
    "..........",
    "..........",
    "...M......",
    "..........",
    "..........",
    "..........",
    "..........",
    "....P.....",
    "..........",
    "..........",
];

function gridToWorld(i, j) {
    const x = (j - HALF_MAP + 0.5) * TILE_SIZE;
    const z = (i - HALF_MAP + 0.5) * TILE_SIZE;
    return new BABYLON.Vector3(x, 0, z);
}

function worldToGrid(x, z) {
    const j = Math.floor(x / TILE_SIZE + HALF_MAP);
    const i = Math.floor(z / TILE_SIZE + HALF_MAP);
    return { i, j };
}

function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.collisionsEnabled = false;

    // Camera
    camera = new BABYLON.UniversalCamera(
        "playerCamera",
        new BABYLON.Vector3(0, CAMERA_HEIGHT, -8),
        scene
    );
    camera.inertia = 0;
    camera.checkCollisions = false;

    // Ambient light (very low)
    const hemi = new BABYLON.HemisphericLight(
        "hemi",
        new BABYLON.Vector3(0, 1, 0),
        scene
    );
    hemi.intensity = 0.1;

    // Player torch: warm point light
    playerLight = new BABYLON.PointLight(
        "playerTorch",
        new BABYLON.Vector3(0.4, 0.4, 1.0),
        scene
    );
    playerLight.parent = camera;
    playerLight.range = 9;
    playerLight.intensity = BASE_TORCH_INTENSITY;
    
    // Warm orange, but not super bright
    playerLight.diffuse  = new BABYLON.Color3(1.0, 0.82, 0.62);
    playerLight.specular = new BABYLON.Color3(0.25, 0.18, 0.12);
    
    // Standard falloff gives a soft fade instead of a harsh bubble
    playerLight.falloffType = BABYLON.Light.FALLOFF_STANDARD;

    // Textures
    const wallTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764146993/dark_stone_wall_yy2jjc.png",
        scene
    );
    const floorTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764146735/dark_stone_floor_uhfk5o.png",
        scene
    );
    const ceilTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764147143/dark_stone_ceil_wepupg.png",
        scene
    );

    const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
    wallMat.diffuseTexture = wallTexture;
    wallMat.specularColor = new BABYLON.Color3(0.1, 0.08, 0.06);

    const floorMat = new BABYLON.StandardMaterial("floorMat", scene);
    floorMat.diffuseTexture = floorTexture;
    floorMat.specularColor = new BABYLON.Color3(0.08, 0.07, 0.05);

    const ceilMat = new BABYLON.StandardMaterial("ceilMat", scene);
    ceilMat.diffuseTexture = ceilTexture;
    ceilMat.specularColor = new BABYLON.Color3(0.08, 0.07, 0.05);

    // Box options
    const wallBoxOptions = {
        width: TILE_SIZE,
        depth: TILE_SIZE,
        height: WALL_HEIGHT,
        wrap: true
    };

    const floorBoxOptions = {
        width: TILE_SIZE,
        depth: TILE_SIZE,
        height: FLOOR_THICKNESS
    };

    const ceilBoxOptions = {
        width: TILE_SIZE,
        depth: TILE_SIZE,
        height: CEILING_THICKNESS
    };

    let playerSpawn = null;
    let monsterSpawnPos = null;

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const pos = gridToWorld(i, j);

            // Floor
            if (groundMap[i][j] === "#") {
                const floor = BABYLON.MeshBuilder.CreateBox(
                    `floor_${i}_${j}`,
                    floorBoxOptions,
                    scene
                );
                floor.position = new BABYLON.Vector3(
                    pos.x,
                    -FLOOR_THICKNESS / 2,
                    pos.z
                );
                floor.material = floorMat;
            }

            // Wall
            if (wallMap[i][j] === "#") {
                const wall = BABYLON.MeshBuilder.CreateBox(
                    `wall_${i}_${j}`,
                    wallBoxOptions,
                    scene
                );
                wall.position = new BABYLON.Vector3(
                    pos.x,
                    WALL_HEIGHT / 2,
                    pos.z
                );
                wall.material = wallMat;
            }

            // Ceiling
            if (ceilingMap[i][j] === "#") {
                const ceil = BABYLON.MeshBuilder.CreateBox(
                    `ceil_${i}_${j}`,
                    ceilBoxOptions,
                    scene
                );
                ceil.position = new BABYLON.Vector3(
                    pos.x,
                    CEILING_Y + CEILING_THICKNESS / 2,
                    pos.z
                );
                ceil.material = ceilMat;
            }

            // Player spawn
            if (objectMap[i][j] === "P") {
                playerSpawn = new BABYLON.Vector3(pos.x, CAMERA_HEIGHT, pos.z);
            }

            // Monster spawn position (we will place imported mesh here)
            if (objectMap[i][j] === "M") {
                monsterSpawnPos = new BABYLON.Vector3(
                    pos.x,
                    0,
                    pos.z
                );
            }
        }
    }

    if (playerSpawn) {
        camera.position = playerSpawn.clone();
    }

    // === Load enemy model from URL ===
    if (monsterSpawnPos) {
        BABYLON.SceneLoader.ImportMesh(
            "",
            MONSTER_MODEL_ROOT,
            MONSTER_MODEL_FILE,
            scene,
            function (meshes) {
                if (!meshes || meshes.length === 0) {
                    console.warn("Monster model not loaded");
                    return;
                }
    
                // Create a single root node and parent all imported meshes
                const root = new BABYLON.TransformNode("monsterRoot", scene);
                meshes.forEach(m => {
                    m.parent = root;
                });
    
                // Start at spawn XZ, y = 0
                root.position = monsterSpawnPos.clone();
                root.rotation = new BABYLON.Vector3(0, Math.PI, 0); // face player
                root.scaling = new BABYLON.Vector3(1, 1, 1);
    
                // --- Scale to target height ---
                const targetHeight = 1.8; // how tall you want the monster (world units)
                const bbox = root.getHierarchyBoundingVectors();
                const currentHeight = bbox.max.y - bbox.min.y || 1;
                const scale = targetHeight / currentHeight;
                root.scaling = new BABYLON.Vector3(scale, scale, scale);
    
                // --- Snap feet to floor (y = 0) ---
                const bbox2 = root.getHierarchyBoundingVectors();
                const lowestY = bbox2.min.y;
                root.position.y -= lowestY; // lift or drop so min.y == 0
    
                // Optional: override material/texture
                if (MONSTER_TEXTURE_URL) {
                    const tex = new BABYLON.Texture(MONSTER_TEXTURE_URL, scene);
                    const mat = new BABYLON.StandardMaterial("monsterMat", scene);
                    mat.diffuseTexture = tex;
                    mat.specularColor = new BABYLON.Color3(0.1, 0.05, 0.05);
                    meshes.forEach(m => m.material = mat);
                }
    
                // Save for game logic
                monsterMesh = root;
            }
        );
    }

    return scene;
}

scene = createScene();

// ===== Movement & Collision =====
const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

function isCircleCollidingWithWalls(pos) {
    const grid = worldToGrid(pos.x, pos.z);
    if (grid.i < 0 || grid.i >= MAP_SIZE || grid.j < 0 || grid.j >= MAP_SIZE) {
        return true;
    }

    for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
            const wi = grid.i + di;
            const wj = grid.j + dj;

            if (wi < 0 || wi >= MAP_SIZE || wj < 0 || wj >= MAP_SIZE) {
                continue;
            }
            if (wallMap[wi][wj] !== "#") continue;

            const xMin = (wj - HALF_MAP) * TILE_SIZE;
            const xMax = xMin + TILE_SIZE;
            const zMin = (wi - HALF_MAP) * TILE_SIZE;
            const zMax = zMin + TILE_SIZE;

            const cx = Math.max(xMin, Math.min(pos.x, xMax));
            const cz = Math.max(zMin, Math.min(pos.z, zMax));

            const dx = pos.x - cx;
            const dz = pos.z - cz;
            if (dx * dx + dz * dz < PLAYER_RADIUS * PLAYER_RADIUS) {
                return true;
            }
        }
    }
    return false;
}

function tryMove(stepVec) {
    const newPos = camera.position.add(stepVec);
    if (!isCircleCollidingWithWalls(newPos)) {
        camera.position = newPos;
    }
}

// ===== Input =====
let btnForwardHeld = false,
    btnBackHeld = false,
    btnTurnLeftHeld = false,
    btnTurnRightHeld = false;

const keys = { forward: false, back: false, left: false, right: false };

function bindHoldButton(id, setter) {
    const btn = document.getElementById(id);
    if (!btn) return;
    btn.addEventListener("mousedown", () => setter(true));
    btn.addEventListener("mouseup", () => setter(false));
    btn.addEventListener("mouseleave", () => setter(false));
    btn.addEventListener("touchstart", e => { e.preventDefault(); setter(true); });
    btn.addEventListener("touchend", e => { e.preventDefault(); setter(false); });
}

bindHoldButton("btn-forward", v => (btnForwardHeld = v));
bindHoldButton("btn-back", v => (btnBackHeld = v));
bindHoldButton("btn-turn-left", v => (btnTurnLeftHeld = v));
bindHoldButton("btn-turn-right", v => (btnTurnRightHeld = v));

window.addEventListener("keydown", e => {
    if (e.key === "w" || e.key === "ArrowUp") keys.forward = true;
    if (e.key === "s" || e.key === "ArrowDown") keys.back = true;
    if (e.key === "a" || e.key === "ArrowLeft") keys.left = true;
    if (e.key === "d" || e.key === "ArrowRight") keys.right = true;
});

window.addEventListener("keyup", e => {
    if (e.key === "w" || e.key === "ArrowUp") keys.forward = false;
    if (e.key === "s" || e.key === "ArrowDown") keys.back = false;
    if (e.key === "a" || e.key === "ArrowLeft") keys.left = false;
    if (e.key === "d" || e.key === "ArrowRight") keys.right = false;
});

// ===== Game loop =====
function update(dt) {
    // rotation
    if (btnTurnLeftHeld || keys.left) {
        camera.rotation.y -= TURN_SPEED * dt;
    }
    if (btnTurnRightHeld || keys.right) {
        camera.rotation.y += TURN_SPEED * dt;
    }

    // movement
    const forward = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
    const flat = new BABYLON.Vector3(forward.x, 0, forward.z).normalize();
    const step = MOVE_SPEED * dt;

    if (btnForwardHeld || keys.forward) {
        tryMove(flat.scale(step));
    }
    if (btnBackHeld || keys.back) {
        tryMove(flat.scale(-step));
    }

    // torch flicker
    torchTime += dt;
    const flicker =
    Math.sin(torchTime * 6.3) * 0.08 +
    Math.sin(torchTime * 11.1) * 0.05 +
    (Math.random() - 0.5) * 0.02;  // tiny random jitter

    let intensity = BASE_TORCH_INTENSITY + flicker;
    // clamp so it never goes crazy bright or fully dark
    intensity = Math.min(1.4, Math.max(0.8, intensity));
    playerLight.intensity = intensity;
}

engine.runRenderLoop(() => {
    const dt = engine.getDeltaTime() / 1000;
    update(dt);
    scene.render();
});

window.addEventListener("resize", () => engine.resize());
</script>

</body>
</html>
