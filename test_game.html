<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KAPLAY 3D Example</title>
<style>
    body {
        margin: 0;
        background: black;
        overflow: hidden;
    }

    canvas {
        width: 100vw;
        height: 100vh;
        display: block;
        image-rendering: pixelated;
    }
</style>
<script src="https://unpkg.com/kaplay/dist/kaplay.js"></script>
</head>

<body>
<script>
// 初始化 kaplay
kaplay({
    width: 800,
    height: 600,
    letterbox: true,
    scale: 1,
});

// Load sprites
loadSprite("bean", "https://play.kaplayjs.com/sprites/bean.png");
loadSprite("wall", "https://play.kaplayjs.com/sprites/brick_wall.png");

let bean, wall;
let objSlices = [];
let slices = [];

// ====== 載入後切割貼圖 ======
onLoad(() => {
    bean = getSprite("bean").data;
    for (let i = 0; i < bean.width; i++) {
        objSlices.push(
            bean.frames[0].scale(
                new Quad(i / bean.width, 0, 1 / bean.width, 1)
            )
        );
    }

    wall = getSprite("wall").data;
    for (let i = 0; i < wall.width; i++) {
        slices.push(
            wall.frames[0].scale(
                new Quad(i / wall.width, 0, 1 / wall.width, 1)
            )
        );
    }
});

// ====== 地圖 ======
const grid = [
    "##################",
    "#                #",
    "# $$$$$$$ $$$$$$ #",
    "# $            $ #",
    "# $ %% %%%%%%% $ #",
    "# $ %        % $ #",
    "#&$&%%%%%  %%%&$&#",
    "# $ %          $ #",
    "# $ %%%%%%%%%%   #",
    "# $            $ #",
    "# $$$$$$$ $$$$$$ #",
    "#          &     #",
    "##################",
];

const colors = {
    "#": RED, "$": GREEN, "%": BLUE, "&": YELLOW,
};

// ====== Camera 物件 ======
const camera = add([
    pos(7 * 16, 11 * 16 + 8),
    rotate(0),
    z(-1),
    rect(8, 8),
    anchor("center"),
    opacity(0),
    body(),
    {
        focalLength: 40,
        fov: 10,

        draw() {

            // ====== 小地圖（上方中央） ======
            pushTransform();
            pushTranslate(vec2(width() / 2 - 120, 20)); // 小地圖位置

            drawRect({
                width: 240,
                height: 120,
                color: rgb(100, 100, 100),
            });
            popTransform();


            // ====== 3D 視野（下面） ======
            pushTransform();
            pushTranslate(vec2(0, 160)); // 整個視窗往下移

            const dir = Vec2.fromAngle(this.angle);
            const perp = dir.normal();

            const planeP1 = this.pos.add(dir.scale(this.focalLength)).add(perp.scale(this.fov)).sub(this.pos);
            const planeP2 = this.pos.add(dir.scale(this.focalLength)).sub(perp.scale(this.fov)).sub(this.pos);

            drawRect({
                width: width(),
                height: height() - 160,
                pos: vec2(0, 0),
                color: rgb(128, 128, 128),
            });

            for (let x = 0; x <= width() / 2; x++) {
                let direction = lerp(planeP1, planeP2, x / (width() / 2)).scale(6);
                const hit = rayCastAsciiGrid(this.pos, direction, grid);

                if (hit) {
                    const t = hit.t;
                    const d = (1 - t);

                    let u = Math.abs(hit.normal.x) > Math.abs(hit.normal.y)
                        ? hit.point.y
                        : hit.point.x;

                    u = (u % 16) / 16;

                    const h = 300 / (t * direction.len() / 16);

                    drawUVQuad({
                        width: 2,
                        height: h,
                        pos: vec2(x * 2, (height() - 160) / 2 - h / 2),
                        tex: wall.tex,
                        quad: slices[Math.floor(u * (wall.width - 1))],
                        color: BLACK.lerp(WHITE, d),
                    });
                }
            }

            popTransform();
        },
    },
]);

// ====== 為 grid 建立碰撞 ======
addLevel(grid, {
    tileWidth: 16,
    tileHeight: 16,
    tiles: {
        "#": () => [rect(16, 16), area(), body({ isStatic: true }), color(RED)],
        "$": () => [rect(16, 16), area(), body({ isStatic: true }), color(GREEN)],
        "%": () => [rect(16, 16), area(), body({ isStatic: true }), color(BLUE)],
        "&": () => [rect(16, 16), color(YELLOW)],
    },
});

// ====== 移動與操作 ======
onKeyDown("up", () => camera.move(Vec2.fromAngle(camera.angle).scale(40)));
onKeyDown("down", () => camera.move(Vec2.fromAngle(camera.angle).scale(-40)));
onKeyDown("left", () => camera.angle -= 90 * dt());
onKeyDown("right", () => camera.angle += 90 * dt());

</script>
</body>
</html>