<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG v0.3.3</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .hp-bar {
        font-size: 14px;
        text-align: center;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        width: 80vw;
        max-width: 480px;
    }

    #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        margin-bottom: 16px;
    }

    #controls .row {
        display: flex;
        gap: 4px;
    }

    #controls button {
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        cursor: pointer;
        min-width: 80px;
    }

    #controls button:active {
        background: #444;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>

<div id="game-wrapper">
    <div id="game">
        <canvas id="renderCanvas"></canvas>
    </div>
    <div id="player-hp" class="hp-bar">Player HP: 100/100</div>
    <div id="debug-angles" class="hp-bar">Cam: 0 | Fire spawn: - | Fire dir: -</div>
</div>

<div id="controls">
    <div class="row">
        <button id="btn-attack">âš”</button>
        <button id="btn-forward">â†‘</button>
        <button id="btn-potion">ðŸ§ª</button>
    </div>
    <div class="row">
        <button id="btn-turn-left">â†º</button>
        <button id="btn-back">â†“</button>
        <button id="btn-turn-right">â†»</button>
    </div>
</div>

<script>
/* ============================================================
   JSON-DRIVEN ASSET LOADING
   ============================================================ */

let ASSETS = null;
let bgm = null;
let footstepLoop = null;

async function loadAssets() {
    const url = "https://termcic.github.io/insect_ecology/assets.json";

    try {
        const res = await fetch(url);
        ASSETS = await res.json();
        console.log("Loaded assets:", ASSETS);
    } catch (err) {
        console.error("Failed to load JSON:", err);
    }

    // Load audio
    if (ASSETS?.audio?.bgm) {
        bgm = new Audio(ASSETS.audio.bgm);
        bgm.loop = true;
        bgm.volume = 0.03;
    }

    if (ASSETS?.audio?.footstep) {
        footstepLoop = new Audio(ASSETS.audio.footstep);
        footstepLoop.loop = true;
        footstepLoop.volume = 0.95;
    }
}

/* ============================================================
   BASIC HELPERS + DOM
   ============================================================ */

function normDeg(a) {
    a = a % 360;
    if (a < 0) a += 360;
    return a;
}

const playerHpEl = document.getElementById("player-hp");
const debugAnglesEl = document.getElementById("debug-angles");

const player = { maxHp: 100, hp: 100, atk: 12 };

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let scene, camera, playerLight;

const MAP_SIZE = 30;
const TILE_SIZE = 2;
const HALF_MAP = MAP_SIZE / 2;

const FLOOR_THICKNESS = 0.2;
const WALL_HEIGHT = 3.0;
const CEILING_THICKNESS = 0.2;
const CEILING_Y = WALL_HEIGHT;

const CAMERA_HEIGHT = 1.4;
const PLAYER_RADIUS = 0.75;

let wantFootsteps = false;

/* ============================================================
   MAPS
   ============================================================ */

const groundMap = [
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################",
  "##############################"
];

const wallMap = [
  "##############################",
  "#............#.##............#",
  "#............#..#............#",
  "#............#..#............#",
  "#............#..#............#",
  "#............##.#............#",
  "#............................#",
  "#..###.##..........######....#",
  "#..#....#...............#....#",
  "#..#....#....#.....#....#....#",
  "#..#....#....###...#....#....#",
  "#..####.#..........###.##....#",
  "#............................#",
  "#............####............#",
  "#............#..#............#",
  "#............#..#............#",
  "#............#...............#",
  "#............####............#",
  "#............................#",
  "#....#########....######.##..#",
  "#....#.......#....#.......#..#",
  "#....#.......#....#.......#..#",
  "#....#####.###....#########..#",
  "#............................#",
  "#............................#",
  "#............................#",
  "#............................#",
  "#............................#",
  "#............................#",
  "##############################"
];

const ceilingMap = groundMap;

/*  
   A/B/C now represent monster types
*/
const objectMap = [
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "...........A..................",
  "..............................",
  "..............................",
  "..............................",
  ".............B................",
  ".....................A........",
  "..............................",
  "..............................",
  "...............C..............",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  "...............P..............",
  "..............................",
  "..............................",
  "..............................",
  "..............................",
  ".............................."
];

/* ============================================================
   GEO HELPERS
   ============================================================ */

function gridToWorld(i, j) {
    const x = (j - HALF_MAP + 0.5) * TILE_SIZE;
    const z = (i - HALF_MAP + 0.5) * TILE_SIZE;
    return new BABYLON.Vector3(x, 0, z);
}

function worldToGrid(x, z) {
    const j = Math.floor(x / TILE_SIZE + HALF_MAP);
    const i = Math.floor(z / TILE_SIZE + HALF_MAP);
    return { i, j };
}

/* ============================================================
   MONSTER SYSTEM â€” JSON DRIVEN
   ============================================================ */

const monsters = [];

function createMonster(scene, worldPos, conf) {
    const plane = BABYLON.MeshBuilder.CreatePlane("monster", { size: conf.scale }, scene);
    plane.position = new BABYLON.Vector3(worldPos.x, 1.1, worldPos.z);

    const tex = new BABYLON.Texture(conf.sprite, scene);
    tex.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
    tex.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
    tex.uScale = 1 / conf.cols;
    tex.vScale = 1 / conf.rows;
    tex.updateSamplingMode(BABYLON.Texture.NEAREST_NEAREST);

    const mat = new BABYLON.StandardMaterial("monsterMat", scene);
    mat.diffuseTexture = tex;
    mat.backFaceCulling = false;
    mat.useAlphaFromDiffuseTexture = true;
    mat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);

    plane.material = mat;

    return {
        mesh: plane,
        hp: conf.maxHp,
        maxHp: conf.maxHp,
        alive: true,
        cooldown: 0,

        frame: 0,
        frameCount: conf.frames,
        framesPerRow: conf.cols,
        animSpeed: conf.speed,
        animTime: 0
    };
}

function spawnMonsters(scene) {
    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const sym = objectMap[i][j];

            if (ASSETS.monsters[sym]) {
                const conf = ASSETS.monsters[sym];
                const pos = gridToWorld(i, j);

                const m = createMonster(scene, pos, conf);
                monsters.push(m);
            }
        }
    }
}

/* ============================================================
   SCENE CREATION â€” TEXTURES FROM JSON
   ============================================================ */

function createScene() {
    const scene = new BABYLON.Scene(engine);

    camera = new BABYLON.UniversalCamera("playerCamera",
        new BABYLON.Vector3(0, CAMERA_HEIGHT, -8), scene);

    camera.inertia = 0;
    camera.checkCollisions = false;
    camera.minZ = 0.01;

    const hemi = new BABYLON.HemisphericLight("hemi",
        new BABYLON.Vector3(0,1,0), scene);
    hemi.intensity = 0.1;

    playerLight = new BABYLON.PointLight("playerTorch",
        new BABYLON.Vector3(0.4,0.4,1.0), scene);
    playerLight.parent = camera;
    playerLight.range = 10.5;
    playerLight.intensity = 1.25;
    playerLight.diffuse  = new BABYLON.Color3(1.0, 0.82, 0.62);

    const wallBoxOptions = { width: TILE_SIZE, depth: TILE_SIZE, height: WALL_HEIGHT };
    const floorBoxOptions = { width: TILE_SIZE, depth: TILE_SIZE, height: FLOOR_THICKNESS };
    const ceilBoxOptions  = { width: TILE_SIZE, depth: TILE_SIZE, height: CEILING_THICKNESS };

    let playerSpawn = null;

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const pos = gridToWorld(i, j);

            // FLOOR
            if (groundMap[i][j] === "#") {
                const floor = BABYLON.MeshBuilder.CreateBox(`floor${i}_${j}`, floorBoxOptions, scene);
                floor.position = new BABYLON.Vector3(pos.x, -FLOOR_THICKNESS/2, pos.z);

                const tex = ASSETS.floors["#"];
                if (tex) {
                    const m = new BABYLON.StandardMaterial(`fm${i}_${j}`, scene);
                    m.diffuseTexture = new BABYLON.Texture(tex, scene);
                    m.diffuseTexture.updateSamplingMode(BABYLON.Texture.NEAREST_NEAREST);
                    floor.material = m;
                }
            }

            // WALL
            if (wallMap[i][j] === "#") {
                const wall = BABYLON.MeshBuilder.CreateBox(`wall${i}_${j}`, wallBoxOptions, scene);
                wall.position = new BABYLON.Vector3(pos.x, WALL_HEIGHT/2, pos.z);

                const tex = ASSETS.walls["#"];
                if (tex) {
                    const m = new BABYLON.StandardMaterial(`wm${i}_${j}`, scene);
                    m.diffuseTexture = new BABYLON.Texture(tex, scene);
                    m.diffuseTexture.updateSamplingMode(BABYLON.Texture.NEAREST_NEAREST);
                    wall.material = m;
                }
            }

            // CEILING
            if (ceilingMap[i][j] === "#") {
                const ceil = BABYLON.MeshBuilder.CreateBox(`ceil${i}_${j}`, ceilBoxOptions, scene);
                ceil.position = new BABYLON.Vector3(pos.x, CEILING_Y + CEILING_THICKNESS/2, pos.z);

                const tex = ASSETS.ceilings["#"];
                if (tex) {
                    const m = new BABYLON.StandardMaterial(`cm${i}_${j}`, scene);
                    m.diffuseTexture = new BABYLON.Texture(tex, scene);
                    m.diffuseTexture.updateSamplingMode(BABYLON.Texture.NEAREST_NEAREST);
                    ceil.material = m;
                }
            }

            if (objectMap[i][j] === "P") {
                playerSpawn = new BABYLON.Vector3(pos.x, CAMERA_HEIGHT, pos.z);
            }
        }
    }

    if (playerSpawn) {
        camera.position = playerSpawn.clone();
    }

    return scene;
}

/* ============================================================
   MOVEMENT, MONSTER AI, LOOP
   ============================================================ */

const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

function isCircleCollidingWithWalls(pos) {
    const grid = worldToGrid(pos.x, pos.z);

    if (grid.i < 0 || grid.i >= MAP_SIZE) return true;
    if (grid.j < 0 || grid.j >= MAP_SIZE) return true;

    for (let di=-1; di<=1; di++) {
        for (let dj=-1; dj<=1; dj++) {
            const wi = grid.i + di;
            const wj = grid.j + dj;

            if (wi<0 || wi>=MAP_SIZE || wj<0 || wj>=MAP_SIZE) continue;
            if (wallMap[wi][wj] !== "#") continue;

            const xMin = (wj - HALF_MAP) * TILE_SIZE;
            const xMax = xMin + TILE_SIZE;
            const zMin = (wi - HALF_MAP) * TILE_SIZE;
            const zMax = zMin + TILE_SIZE;

            const cx = Math.max(xMin, Math.min(pos.x, xMax));
            const cz = Math.max(zMin, Math.min(pos.z, zMax));

            const dx = pos.x - cx;
            const dz = pos.z - cz;

            if (dx*dx + dz*dz < PLAYER_RADIUS*PLAYER_RADIUS) return true;
        }
    }
    return false;
}

function tryMove(step) {
    let moved = false;

    const posX = camera.position.add(new BABYLON.Vector3(step.x, 0, 0));
    if (!isCircleCollidingWithWalls(posX)) {
        camera.position.x = posX.x;
        moved = true;
    }

    const posZ = camera.position.add(new BABYLON.Vector3(0, 0, step.z));
    if (!isCircleCollidingWithWalls(posZ)) {
        camera.position.z = posZ.z;
        moved = true;
    }

    return moved;
}

/* INPUT */

let btnForwardHeld = false,
    btnBackHeld = false,
    btnTurnLeftHeld = false,
    btnTurnRightHeld = false;

const keys = { forward:false, back:false, left:false, right:false };

function bindHoldButton(id, setter) {
    const btn = document.getElementById(id);
    btn.addEventListener("mousedown", () => setter(true));
    btn.addEventListener("mouseup",   () => setter(false));
    btn.addEventListener("mouseleave",() => setter(false));
    btn.addEventListener("touchstart", e => { e.preventDefault(); setter(true); });
    btn.addEventListener("touchend",   e => { e.preventDefault(); setter(false); });
}

bindHoldButton("btn-forward", v => btnForwardHeld=v);
bindHoldButton("btn-back",    v => btnBackHeld=v);
bindHoldButton("btn-turn-left",  v => btnTurnLeftHeld=v);
bindHoldButton("btn-turn-right", v => btnTurnRightHeld=v);

window.addEventListener("keydown", e => {
    if (e.key==="w"||e.key==="ArrowUp") keys.forward=true;
    if (e.key==="s"||e.key==="ArrowDown") keys.back=true;
    if (e.key==="a"||e.key==="ArrowLeft") keys.left=true;
    if (e.key==="d"||e.key==="ArrowRight") keys.right=true;
});
window.addEventListener("keyup", e => {
    if (e.key==="w"||e.key==="ArrowUp") keys.forward=false;
    if (e.key==="s"||e.key==="ArrowDown") keys.back=false;
    if (e.key==="a"||e.key==="ArrowLeft") keys.left=false;
    if (e.key==="d"||e.key==="ArrowRight") keys.right=false;
});

/* GAME LOOP */

function update(dt) {
    // rotation
    if (btnTurnLeftHeld || keys.left)  camera.rotation.y -= TURN_SPEED*dt;
    if (btnTurnRightHeld || keys.right)camera.rotation.y += TURN_SPEED*dt;

    const forward = camera.getDirection(new BABYLON.Vector3(0,0,1));
    const flat = new BABYLON.Vector3(forward.x,0,forward.z).normalize();
    const step = MOVE_SPEED * dt;
    let moved = false;

    if (btnForwardHeld || keys.forward) moved |= tryMove(flat.scale(step));
    if (btnBackHeld    || keys.back   ) moved |= tryMove(flat.scale(-step));

    // FOOTSTEPS
    wantFootsteps = moved;
    if (footstepLoop) {
        if (wantFootsteps && footstepLoop.paused) {
            footstepLoop.play().catch(()=>{});
        } else if (!wantFootsteps && !footstepLoop.paused) {
            footstepLoop.pause();
        }
    }

    // MONSTER AI + Animation
    for (const m of monsters) {
        if (!m.alive) continue;

        m.animTime += dt;
        if (m.animTime >= m.animSpeed) {
            m.animTime = 0;
            m.frame = (m.frame + 1) % m.frameCount;

            const col = m.frame % m.framesPerRow;
            const row = Math.floor(m.frame / m.framesPerRow);

            m.mesh.material.diffuseTexture.uOffset = col / m.framesPerRow;
            m.mesh.material.diffuseTexture.vOffset = row / m.framesPerRow;
        }

        const dx = camera.position.x - m.mesh.position.x;
        const dz = camera.position.z - m.mesh.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);

        m.mesh.rotation.y = Math.atan2(dx, dz);

        if (dist < 8 && dist > 1.5) {
            const spd = 1.4 * dt;
            m.mesh.position.x += (dx/dist)*spd;
            m.mesh.position.z += (dz/dist)*spd;
        }

        if (dist < 1.5) {
            if (m.cooldown <= 0) {
                player.hp -= 4;
                m.cooldown = 1.2;
            }
        }

        if (m.cooldown > 0) m.cooldown -= dt;
    }

    playerHpEl.textContent = `Player HP: ${player.hp}/${player.maxHp}`;
}

document.getElementById("btn-attack").onclick = () => {
    for (const m of monsters) {
        if (!m.alive) continue;

        const dx = camera.position.x - m.mesh.position.x;
        const dz = camera.position.z - m.mesh.position.z;
        const dist = Math.hypot(dx, dz);

        if (dist < 2.2) {
            m.hp -= 12;
            if (m.hp <= 0) {
                m.alive = false;
                m.mesh.dispose();
            }
        }
    }
};

/* ============================================================
   ASYNC STARTUP â€” load JSON, build scene, spawn monsters
   ============================================================ */

(async () => {
    await loadAssets();

    scene = createScene();
    spawnMonsters(scene);

    engine.runRenderLoop(() => {
        const dt = engine.getDeltaTime()/1000;
        update(dt);
        scene.render();

        if (bgm && bgm.paused) {
            bgm.play().catch(()=>{});
        }
    });
})();

window.addEventListener("resize", () => engine.resize());
window.addEventListener("click", () => {
    if (bgm && bgm.paused) bgm.play().catch(()=>{});
});
</script>

</body>
</html>
