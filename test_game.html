<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG v0.2.4</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }
    #game { width: 80vw; max-width:480px; aspect-ratio:1/1; background:black; border:4px solid #555; }
    canvas { width:100%; height:100%; display:block; }
</style>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>

<div id="game">
    <canvas id="renderCanvas"></canvas>
</div>

<script>
// ------------------------------------------------------------
// 基本變數
// ------------------------------------------------------------
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let scene, camera, playerLight;
let playerPos = null;   // 玩家真正位置（唯一一個）

const MAP_SIZE = 30;
const TILE = 2;
const HALF = MAP_SIZE / 2;
const PLAYER_HEIGHT = 1.4;
const PLAYER_RADIUS = 0.6;
const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

// ------------------------------------------------------------
// 地圖（沿用你原本的）
// ------------------------------------------------------------
const wallMap = [
"##############################",
"#............#.##............#",
"#............#..#............#",
"#............#..#............#",
"#............#..#............#",
"#............##.#............#",
"#............................#",
"#..###.##..........######....#",
"#..#....#...............#....#",
"#..#....#....#.....#....#....#",
"#..#....#....###...#....#....#",
"#..####.#..........###.##....#",
"#............................#",
"#............####............#",
"#............#..#............#",
"#............#..#............#",
"#............#...............#",
"#............####............#",
"#............................#",
"#....#########....######.##..#",
"#....#.......#....#.......#..#",
"#....#.......#....#.......#..#",
"#....#####.###....#########..#",
"#............................#",
"#............................#",
"#............................#",
"#............................#",
"#............................#",
"#............................#",
"##############################"
];

const objectMap = [
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"...............M..............",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"..............................",
"...............P..............",
"..............................",
"..............................",
"..............................",
"..............................",
".............................."
];

// ------------------------------------------------------------
// 工具
// ------------------------------------------------------------
function gridToWorld(i, j) {
    return new BABYLON.Vector3(
        (j - HALF + 0.5) * TILE,
        0,
        (i - HALF + 0.5) * TILE
    );
}

function isWall(i, j) {
    if (i < 0 || i >= MAP_SIZE || j < 0 || j >= MAP_SIZE) return true;
    return wallMap[i][j] === "#";
}

// ------------------------------------------------------------
// 建立場景
// ------------------------------------------------------------
function createScene() {
    const scene = new BABYLON.Scene(engine);

    camera = new BABYLON.UniversalCamera("cam", new BABYLON.Vector3(0, PLAYER_HEIGHT, 0), scene);
    camera.inertia = 0;

    // torch light
    playerLight = new BABYLON.PointLight("torch", new BABYLON.Vector3(0.4, 0.4, 1.0), scene);
    playerLight.parent = camera;
    playerLight.intensity = 1.25;
    playerLight.range = 10;

    const wallTex = new BABYLON.Texture("https://res.cloudinary.com/dmdpjf8up/image/upload/v1764201544/dark_stone_wall_3_bclnch.png");
    const floorTex = new BABYLON.Texture("https://res.cloudinary.com/dmdpjf8up/image/upload/v1764202147/dark_stone_floor_2_km9hfy.png");
    const ceilTex = new BABYLON.Texture("https://res.cloudinary.com/dmdpjf8up/image/upload/v1764147143/dark_stone_ceil_wepupg.png");

    const wallMat = new BABYLON.StandardMaterial("wm", scene);
    wallMat.diffuseTexture = wallTex;

    const floorMat = new BABYLON.StandardMaterial("fm", scene);
    floorMat.diffuseTexture = floorTex;

    const ceilMat = new BABYLON.StandardMaterial("cm", scene);
    ceilMat.diffuseTexture = ceilTex;

    // 建立地板/牆/天花
    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {

            const pos = gridToWorld(i, j);

            // floor
            const f = BABYLON.MeshBuilder.CreateGround(`f${i}_${j}`, { width: TILE, height: TILE }, scene);
            f.position = pos.clone();
            f.material = floorMat;

            // ceil
            const c = BABYLON.MeshBuilder.CreateGround(`c${i}_${j}`, { width:TILE, height:TILE }, scene);
            c.position = pos.clone();
            c.position.y = 3.2;
            c.rotation.x = Math.PI;
            c.material = ceilMat;

            // wall
            if (isWall(i, j)) {
                const w = BABYLON.MeshBuilder.CreateBox(`w${i}_${j}`, { width:TILE, height:3, depth:TILE }, scene);
                w.position = pos.clone();
                w.position.y = 1.5;
                w.material = wallMat;
            }

            if (objectMap[i][j] === "P") {
                playerPos = new BABYLON.Vector3(pos.x, 0, pos.z);
                camera.position = new BABYLON.Vector3(pos.x, PLAYER_HEIGHT, pos.z);
            }
        }
    }

    return scene;
}

scene = createScene();

// ------------------------------------------------------------
// 碰撞
// ------------------------------------------------------------
function collides(vec) {
    const i = Math.floor(vec.z / TILE + HALF);
    const j = Math.floor(vec.x / TILE + HALF);

    // 檢查自身格子與周邊 8 格
    for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
            if (isWall(i + di, j + dj)) {

                // 計算牆 bounding box
                const wx = (j + dj - HALF) * TILE;
                const wz = (i + di - HALF) * TILE;

                const xMin = wx;
                const xMax = wx + TILE;
                const zMin = wz;
                const zMax = wz + TILE;

                const cx = Math.max(xMin, Math.min(vec.x, xMax));
                const cz = Math.max(zMin, Math.min(vec.z, zMax));

                const dx = vec.x - cx;
                const dz = vec.z - cz;

                if (dx*dx + dz*dz < PLAYER_RADIUS*PLAYER_RADIUS)
                    return true;
            }
        }
    }
    return false;
}

// ------------------------------------------------------------
// 控制
// ------------------------------------------------------------
const keys = { f:false, b:false, l:false, r:false };

window.onkeydown = e => {
    if (e.key==="w") keys.f=true;
    if (e.key==="s") keys.b=true;
    if (e.key==="a") keys.l=true;
    if (e.key==="d") keys.r=true;
};

window.onkeyup = e => {
    if (e.key==="w") keys.f=false;
    if (e.key==="s") keys.b=false;
    if (e.key==="a") keys.l=false;
    if (e.key==="d") keys.r=false;
};

// ------------------------------------------------------------
// 更新
// ------------------------------------------------------------
engine.runRenderLoop(() => {
    const dt = engine.getDeltaTime() / 1000;

    // 旋轉
    if (keys.l) camera.rotation.y -= TURN_SPEED * dt;
    if (keys.r) camera.rotation.y += TURN_SPEED * dt;

    // 前後移動
    const fw = camera.getDirection(new BABYLON.Vector3(0,0,1));
    fw.y = 0;
    fw.normalize();

    let moved = false;

    if (keys.f) {
        const np = playerPos.add(fw.scale(MOVE_SPEED * dt));
        if (!collides(np)) { playerPos = np; moved = true; }
    }
    if (keys.b) {
        const np = playerPos.add(fw.scale(-MOVE_SPEED * dt));
        if (!collides(np)) { playerPos = np; moved = true; }
    }

    camera.position.x = playerPos.x;
    camera.position.z = playerPos.z;

    scene.render();
});
</script>

</body>
</html>
