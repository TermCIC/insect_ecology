<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG Babylon v0.1</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .hp-bar {
        font-size: 14px;
        text-align: center;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        width: 80vw;
        max-width: 480px;
    }

    #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    @media (orientation: landscape) {
        #game {
            height: 70vh;
            width: auto;
        }
    }

    @media (orientation: portrait) {
        body {
            justify-content: flex-start;
            padding-top: 16px;
            height: auto;
        }

        #game {
            width: 95vw;
            height: 95vw;
        }

        #controls {
            width: 95vw;
            gap: 6px;
            min-height: 96px;
            margin-top: 8px;
        }

        #controls .row {
            width: 100%;
        }

        #controls button {
            flex: 1;
            min-height: 56px;
            padding: 10px 0;
            font-size: 5vw;
            box-sizing: border-box;
        }
    }

    #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        margin-bottom: 16px;
    }

    #controls .row {
        display: flex;
        gap: 4px;
    }

    #controls button {
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        cursor: pointer;
        min-width: 80px;
    }

    #controls button:active {
        background: #444;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>

<div id="game-wrapper">
    <div id="monster-hp" class="hp-bar">Monster HP: -</div>
    <div id="game">
        <canvas id="renderCanvas"></canvas>
    </div>
    <div id="player-hp" class="hp-bar">Player HP: 100/100</div>
    <div id="debug-angles" class="hp-bar">Cam: 0 | Fire spawn: - | Fire dir: -</div>
</div>

<div id="controls">
    <div class="row">
        <button id="btn-attack">âš”</button>
        <button id="btn-forward">â†‘</button>
        <button id="btn-potion">ðŸ§ª</button>
    </div>
    <div class="row">
        <button id="btn-turn-left">â†º</button>
        <button id="btn-back">â†“</button>
        <button id="btn-turn-right">â†»</button>
    </div>
</div>

<script>
// ===== Helpers =====
function normDeg(a) {
    a = a % 360;
    if (a < 0) a += 360;
    return a;
}

// ===== DOM UI =====
const playerHpEl    = document.getElementById("player-hp");
const monsterHpEl   = document.getElementById("monster-hp");
const debugAnglesEl = document.getElementById("debug-angles");

// ===== Player and monster state =====
const player = {
    maxHp: 100,
    hp: 100,
    atk: 12,
};

const monsterState = {
    maxHp: 40,
    hp: 40,
    atk: 6,
    alive: true,
    cooldown: 0,
};

const ATTACK_RANGE = 3.0; // in world units
const MONSTER_ATTACK_INTERVAL = 1.0;

// Projectiles
const FIREBALL_SPEED   = 12;
const FIREBALL_LIFETIME = 3;
const FIREBALL_RADIUS   = 0.4;

let lastFireSpawnAngleDeg = null;
let lastFireDirAngleDeg   = null;

function updatePlayerHpUI() {
    playerHpEl.textContent = `Player HP: ${player.hp}/${player.maxHp}`;
}

function updateMonsterHpUI() {
    if (!monsterState.alive) {
        monsterHpEl.textContent = "Monster HP: -";
    } else {
        monsterHpEl.textContent = `Monster HP: ${monsterState.hp}/${monsterState.maxHp}`;
    }
}

function updateDebugAngles(camera) {
    if (!debugAnglesEl || !camera) return;
    const yawDeg = normDeg(BABYLON.Tools.ToDegrees(camera.rotation.y));

    const fireSpawnText = lastFireSpawnAngleDeg != null
        ? lastFireSpawnAngleDeg.toFixed(2)
        : "-";

    const fireDirText = lastFireDirAngleDeg != null
        ? lastFireDirAngleDeg.toFixed(2)
        : "-";

    debugAnglesEl.textContent =
        `Cam: ${yawDeg.toFixed(2)} | Fire spawn: ${fireSpawnText} | Fire dir: ${fireDirText}`;
}

// ===== Babylon setup =====
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let scene;
let camera;
let monsterMesh;
const projectiles = [];

function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.05, 1);

    // Camera
    camera = new BABYLON.UniversalCamera(
        "playerCamera",
        new BABYLON.Vector3(0, 1.6, -8),
        scene
    );
    camera.rotation.y = 0;
    camera.inertia = 0;
    camera.speed = 0;

    // Lights
    const hemi = new BABYLON.HemisphericLight(
        "hemi",
        new BABYLON.Vector3(0, 1, 0),
        scene
    );
    hemi.intensity = 0.7;

    const point = new BABYLON.PointLight(
        "point",
        new BABYLON.Vector3(0, 2.5, -6),
        scene
    );
    point.intensity = 0.6;

    // --- Textures ---
    const wallTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764073173/brick_wall_1_hjoaxn.png",
        scene
    );
    wallTexture.uScale = 6;   // repeat horizontally
    wallTexture.vScale = 3;   // repeat vertically

    const floorTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764057126/brick_wall_5_qtebvm.png",
        scene
    );
    floorTexture.uScale = 6;
    floorTexture.vScale = 18;

    const ceilTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764073221/brick_wall_2_ua8zgt.png",
        scene
    );
    ceilTexture.uScale = 6;
    ceilTexture.vScale = 18;

    // Ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {
        width: 10,
        height: 30,
    }, scene);
    ground.position.z = 0;

    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseTexture = floorTexture;
    groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
    ground.material = groundMat;

    // Ceiling
    const ceiling = BABYLON.MeshBuilder.CreateGround("ceiling", {
        width: 10,
        height: 30,
    }, scene);
    ceiling.position.y = 3;
    ceiling.position.z = 0;
    ceiling.rotation.x = Math.PI;

    const ceilMat = new BABYLON.StandardMaterial("ceilMat", scene);
    ceilMat.diffuseTexture = ceilTexture;
    ceilMat.specularColor = new BABYLON.Color3(0, 0, 0);
    ceiling.material = ceilMat;

    // Walls
    const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
    wallMat.diffuseTexture = wallTexture;
    wallMat.specularColor = new BABYLON.Color3(0, 0, 0);
    wallMat.backFaceCulling = false;

    const leftWall = BABYLON.MeshBuilder.CreateBox("leftWall", {
        width: 0.3,
        height: 3,
        depth: 30,
    }, scene);
    leftWall.position = new BABYLON.Vector3(-3, 1.5, 0);
    leftWall.material = wallMat;

    const rightWall = leftWall.clone("rightWall");
    rightWall.position.x = 3;

    const endWall = BABYLON.MeshBuilder.CreateBox("endWall", {
        width: 6,
        height: 3,
        depth: 0.3,
    }, scene);
    endWall.position = new BABYLON.Vector3(0, 1.5, 8);
    endWall.material = wallMat;

    // Monster
    monsterMesh = BABYLON.MeshBuilder.CreateBox("monster", {
        size: 1.2,
    }, scene);
    monsterMesh.position = new BABYLON.Vector3(0, 1.0, 4);

    const monsterMat = new BABYLON.StandardMaterial("monsterMat", scene);
    monsterMat.diffuseColor = new BABYLON.Color3(0.6, 0.1, 0.1);
    monsterMat.emissiveColor = new BABYLON.Color3(0.3, 0, 0);
    monsterMesh.material = monsterMat;

    return scene;
}

scene = createScene();

// ===== Input handling =====
let btnForwardHeld   = false;
let btnBackHeld      = false;
let btnTurnLeftHeld  = false;
let btnTurnRightHeld = false;

function bindHoldButton(id, setter) {
    const btn = document.getElementById(id);
    btn.addEventListener("mousedown",  () => setter(true));
    btn.addEventListener("mouseup",    () => setter(false));
    btn.addEventListener("mouseleave", () => setter(false));
    btn.addEventListener("touchstart", e => { e.preventDefault(); setter(true); });
    btn.addEventListener("touchend",   e => { e.preventDefault(); setter(false); });
}

bindHoldButton("btn-forward",    v => btnForwardHeld   = v);
bindHoldButton("btn-back",       v => btnBackHeld      = v);
bindHoldButton("btn-turn-left",  v => btnTurnLeftHeld  = v);
bindHoldButton("btn-turn-right", v => btnTurnRightHeld = v);

document.getElementById("btn-potion").addEventListener("click", () => {
    player.hp = Math.min(player.maxHp, player.hp + 25);
    updatePlayerHpUI();
});

document.getElementById("btn-attack").addEventListener("click", () => {
    spawnFireball();
});

// Keyboard
const keys = {
    forward: false,
    back: false,
    left: false,
    right: false,
};

window.addEventListener("keydown", e => {
    if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") keys.forward = true;
    if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") keys.back = true;
    if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") keys.left = true;
    if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") keys.right = true;
    if (e.code === "Space") spawnFireball();
    if (e.key === "h" || e.key === "H") {
        player.hp = Math.min(player.maxHp, player.hp + 25);
        updatePlayerHpUI();
    }
});

window.addEventListener("keyup", e => {
    if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") keys.forward = false;
    if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") keys.back = false;
    if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") keys.left = false;
    if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") keys.right = false;
});

// ===== Fireballs =====
function spawnFireball() {
    if (!monsterState.alive) return;

    const origin = camera.position.clone();
    const dir = camera.getDirection(new BABYLON.Vector3(0, 0, 1)).normalize();

    const fbMesh = BABYLON.MeshBuilder.CreateSphere("fireball", {
        diameter: FIREBALL_RADIUS,
        segments: 8,
    }, scene);

    fbMesh.position = origin.add(dir.scale(1.0));

    const fbMat = new BABYLON.StandardMaterial("fbMat", scene);
    fbMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
    fbMat.diffuseColor = new BABYLON.Color3(0.9, 0.4, 0);
    fbMesh.material = fbMat;

    projectiles.push({
        mesh: fbMesh,
        dir: dir,
        life: FIREBALL_LIFETIME,
    });

    const yawDeg = normDeg(BABYLON.Tools.ToDegrees(camera.rotation.y));
    lastFireSpawnAngleDeg = yawDeg;
    lastFireDirAngleDeg = yawDeg;
}

// ===== Game update =====
const MOVE_SPEED = 4;           // units per second
const TURN_SPEED = Math.PI;     // radians per second

function update(dt) {
    if (!camera) return;

    // Movement
    const moveForward = btnForwardHeld || keys.forward;
    const moveBack    = btnBackHeld || keys.back;
    const turnLeft    = btnTurnLeftHeld || keys.left;
    const turnRight   = btnTurnRightHeld || keys.right;

    if (turnLeft) {
        camera.rotation.y -= TURN_SPEED * dt;
    }
    if (turnRight) {
        camera.rotation.y += TURN_SPEED * dt;
    }

    const forwardDir = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
    const forwardNorm = forwardDir.normalize();

    if (moveForward) {
        camera.position.addInPlace(forwardNorm.scale(MOVE_SPEED * dt));
    }
    if (moveBack) {
        camera.position.addInPlace(forwardNorm.scale(-MOVE_SPEED * dt));
    }

    // Update projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.life -= dt;
        if (p.life <= 0) {
            p.mesh.dispose();
            projectiles.splice(i, 1);
            continue;
        }

        p.mesh.position.addInPlace(p.dir.scale(FIREBALL_SPEED * dt));

        // Hit monster
        if (monsterState.alive && monsterMesh) {
            const dist = BABYLON.Vector3.Distance(p.mesh.position, monsterMesh.position);
            if (dist < 0.8) {
                monsterState.hp = Math.max(0, monsterState.hp - player.atk);
                if (monsterState.hp <= 0) {
                    monsterState.alive = false;
                    monsterMesh.dispose();
                }
                p.mesh.dispose();
                projectiles.splice(i, 1);
            }
        }
    }

    // Monster attack
    if (monsterState.alive && monsterMesh) {
        const dist = BABYLON.Vector3.Distance(camera.position, monsterMesh.position);
        monsterState.cooldown -= dt;
        if (dist <= ATTACK_RANGE && monsterState.cooldown <= 0) {
            player.hp = Math.max(0, player.hp - monsterState.atk);
            monsterState.cooldown = MONSTER_ATTACK_INTERVAL;
        }
    }

    updatePlayerHpUI();
    updateMonsterHpUI();
    updateDebugAngles(camera);
}

// ===== Main loop =====
updatePlayerHpUI();
updateMonsterHpUI();

engine.runRenderLoop(function () {
    const dt = engine.getDeltaTime() / 1000;
    update(dt);
    scene.render();
});

window.addEventListener("resize", function () {
    engine.resize();
});
</script>

</body>
</html>
