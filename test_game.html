<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG v0.0.3</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .hp-bar {
        font-size: 14px;
        text-align: center;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        width: 80vw;
        max-width: 480px;
    }

    #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    @media (orientation: landscape) {
        #game {
            height: 70vh;
            width: auto;
        }
    }

    @media (orientation: portrait) {
        body {
            justify-content: flex-start;
            padding-top: 16px;
            height: auto;
        }

        #game {
            width: 95vw;
            height: 95vw;
        }

        #controls {
            width: 95vw;
            gap: 6px;
            min-height: 96px;
            margin-top: 8px;
        }

        #controls .row {
            width: 100%;
        }

        #controls button {
            flex: 1;
            min-height: 56px;
            padding: 10px 0;
            font-size: 5vw;
            box-sizing: border-box;
        }
    }

    #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        margin-bottom: 16px;
    }

    #controls .row {
        display: flex;
        gap: 4px;
    }

    #controls button {
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        cursor: pointer;
        min-width: 80px;
    }

    #controls button:active {
        background: #444;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>

<div id="game-wrapper">
    <div id="monster-hp" class="hp-bar">Monster HP: -</div>
    <div id="game">
        <canvas id="renderCanvas"></canvas>
    </div>
    <div id="player-hp" class="hp-bar">Player HP: 100/100</div>
    <div id="debug-angles" class="hp-bar">Cam: 0 | Fire spawn: - | Fire dir: -</div>
</div>

<div id="controls">
    <div class="row">
        <button id="btn-attack">âš”</button>
        <button id="btn-forward">â†‘</button>
        <button id="btn-potion">ðŸ§ª</button>
    </div>
    <div class="row">
        <button id="btn-turn-left">â†º</button>
        <button id="btn-back">â†“</button>
        <button id="btn-turn-right">â†»</button>
    </div>
</div>

<script>
// ===== Helpers =====
function normDeg(a) {
    a = a % 360;
    if (a < 0) a += 360;
    return a;
}

// ===== DOM UI =====
const playerHpEl    = document.getElementById("player-hp");
const monsterHpEl   = document.getElementById("monster-hp");
const debugAnglesEl = document.getElementById("debug-angles");

// ===== Player and monster state =====
const player = {
    maxHp: 100,
    hp: 100,
    atk: 12,
};

const monsterState = {
    maxHp: 40,
    hp: 40,
    atk: 6,
    alive: true,
    cooldown: 0,
};

const ATTACK_RANGE = 3.0;
const MONSTER_ATTACK_INTERVAL = 1.0;

// Projectiles
const FIREBALL_SPEED    = 12;
const FIREBALL_LIFETIME = 3;
const FIREBALL_RADIUS   = 0.4;

let lastFireSpawnAngleDeg = null;
let lastFireDirAngleDeg   = null;

function updatePlayerHpUI() {
    playerHpEl.textContent = `Player HP: ${player.hp}/${player.maxHp}`;
}

function updateMonsterHpUI() {
    if (!monsterState.alive) {
        monsterHpEl.textContent = "Monster HP: -";
    } else {
        monsterHpEl.textContent = `Monster HP: ${monsterState.hp}/${monsterState.maxHp}`;
    }
}

function updateDebugAngles(camera) {
    if (!debugAnglesEl || !camera) return;
    const yawDeg = normDeg(BABYLON.Tools.ToDegrees(camera.rotation.y));

    const fireSpawnText = lastFireSpawnAngleDeg != null
        ? lastFireSpawnAngleDeg.toFixed(2)
        : "-";

    const fireDirText = lastFireDirAngleDeg != null
        ? lastFireDirAngleDeg.toFixed(2)
        : "-";

    debugAnglesEl.textContent =
        `Cam: ${yawDeg.toFixed(2)} | Fire spawn: ${fireSpawnText} | Fire dir: ${fireDirText}`;
}

// ===== Babylon setup =====
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let scene;
let camera;
let monsterMesh = null;
const projectiles = [];

// ===== ASCII maps (10 x 10) =====
const MAP_SIZE = 10;

// '.' = empty, '#' = solid floor tile (visual only here)
const groundMap = [
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
];

// wall layer for collision
const wallMap = [
    "##########",
    "#........#",
    "#...#....#",
    "#........#",
    "#........#",
    "#..###...#",
    "#........#",
    "#........#",
    "#........#",
    "##########",
];

// ceiling layer
const ceilingMap = [
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
    "##########",
];

// object layer: P = player, M = monster
const objectMap = [
    "..........",
    "..........",
    "...M......",
    "..........",
    "..........",
    "..........",
    "..........",
    "....P.....",
    "..........",
    "..........",
];

// ===== Map parameters =====
const TILE_SIZE      = 2;
const HALF_MAP       = MAP_SIZE / 2;
const FLOOR_Y        = 0;
const WALL_Y         = TILE_SIZE;
const CEILING_Y      = TILE_SIZE * 2;

function gridToWorld(i, j) {
    const x = (j - HALF_MAP + 0.5) * TILE_SIZE;
    const z = (i - HALF_MAP + 0.5) * TILE_SIZE;
    return new BABYLON.Vector3(x, 0, z);
}

// convert world x,z back to grid i,j
function worldToGrid(x, z) {
    const j = Math.floor(x / TILE_SIZE + HALF_MAP);
    const i = Math.floor(z / TILE_SIZE + HALF_MAP);
    return { i, j };
}

function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.05, 1);

    // Camera
    camera = new BABYLON.UniversalCamera(
        "playerCamera",
        new BABYLON.Vector3(0, WALL_Y, -8),
        scene
    );
    camera.rotation.y = 0;
    camera.inertia = 0;
    camera.speed = 0;

    // Lights
    const hemi = new BABYLON.HemisphericLight(
        "hemi",
        new BABYLON.Vector3(0, 1, 0),
        scene
    );
    hemi.intensity = 0.7;

    const point = new BABYLON.PointLight(
        "point",
        new BABYLON.Vector3(0, CEILING_Y + 1, 0),
        scene
    );
    point.intensity = 0.6;

    // Textures and materials
    const wallTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764056065/brick_wall_3_asxofr.png",
        scene
    );
    const floorTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764056933/brick_wall_4_xuoebx.png",
        scene
    );
    const ceilTexture = new BABYLON.Texture(
        "https://res.cloudinary.com/dmdpjf8up/image/upload/v1764057126/brick_wall_5_qtebvm.png",
        scene
    );

    const floorMat = new BABYLON.StandardMaterial("floorMat", scene);
    floorMat.diffuseTexture = floorTexture;
    floorMat.specularColor = new BABYLON.Color3(0, 0, 0);

    const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
    wallMat.diffuseTexture = wallTexture;
    wallMat.specularColor = new BABYLON.Color3(0, 0, 0);
    wallMat.backFaceCulling = false;

    const ceilMat = new BABYLON.StandardMaterial("ceilMat", scene);
    ceilMat.diffuseTexture = ceilTexture;
    ceilMat.specularColor = new BABYLON.Color3(0, 0, 0);

    // Build cubes
    let playerSpawn = null;

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const posXZ = gridToWorld(i, j);

            if (groundMap[i][j] === "#") {
                const box = BABYLON.MeshBuilder.CreateBox(
                    `floor_${i}_${j}`,
                    { size: TILE_SIZE },
                    scene
                );
                box.position = new BABYLON.Vector3(posXZ.x, FLOOR_Y, posXZ.z);
                box.material = floorMat;
            }

            if (wallMap[i][j] === "#") {
                const box = BABYLON.MeshBuilder.CreateBox(
                    `wall_${i}_${j}`,
                    { size: TILE_SIZE },
                    scene
                );
                box.position = new BABYLON.Vector3(posXZ.x, WALL_Y, posXZ.z);
                box.material = wallMat;
            }

            if (ceilingMap[i][j] === "#") {
                const box = BABYLON.MeshBuilder.CreateBox(
                    `ceil_${i}_${j}`,
                    { size: TILE_SIZE },
                    scene
                );
                box.position = new BABYLON.Vector3(posXZ.x, CEILING_Y, posXZ.z);
                box.material = ceilMat;
            }

            const objChar = objectMap[i][j];
            if (objChar === "P") {
                playerSpawn = new BABYLON.Vector3(posXZ.x, WALL_Y, posXZ.z);
            } else if (objChar === "M" && !monsterMesh) {
                monsterMesh = BABYLON.MeshBuilder.CreateBox(
                    "monster",
                    { size: TILE_SIZE * 0.8 },
                    scene
                );
                monsterMesh.position = new BABYLON.Vector3(posXZ.x, WALL_Y, posXZ.z);
                const monsterMat = new BABYLON.StandardMaterial("monsterMat", scene);
                monsterMat.diffuseColor = new BABYLON.Color3(0.6, 0.1, 0.1);
                monsterMat.emissiveColor = new BABYLON.Color3(0.3, 0, 0);
                monsterMesh.material = monsterMat;
            }
        }
    }

    if (playerSpawn) {
        camera.position = playerSpawn.clone();
    }

    return scene;
}

scene = createScene();

// ===== Input handling =====
let btnForwardHeld   = false;
let btnBackHeld      = false;
let btnTurnLeftHeld  = false;
let btnTurnRightHeld = false;

function bindHoldButton(id, setter) {
    const btn = document.getElementById(id);
    btn.addEventListener("mousedown",  () => setter(true));
    btn.addEventListener("mouseup",    () => setter(false));
    btn.addEventListener("mouseleave", () => setter(false));
    btn.addEventListener("touchstart", e => { e.preventDefault(); setter(true); });
    btn.addEventListener("touchend",   e => { e.preventDefault(); setter(false); });
}

bindHoldButton("btn-forward",    v => btnForwardHeld   = v);
bindHoldButton("btn-back",       v => btnBackHeld      = v);
bindHoldButton("btn-turn-left",  v => btnTurnLeftHeld  = v);
bindHoldButton("btn-turn-right", v => btnTurnRightHeld = v);

document.getElementById("btn-potion").addEventListener("click", () => {
    player.hp = Math.min(player.maxHp, player.hp + 25);
    updatePlayerHpUI();
});

document.getElementById("btn-attack").addEventListener("click", () => {
    spawnFireball();
});

// Keyboard
const keys = { forward: false, back: false, left: false, right: false };

window.addEventListener("keydown", e => {
    if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") keys.forward = true;
    if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") keys.back = true;
    if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") keys.left = true;
    if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") keys.right = true;
    if (e.code === "Space") spawnFireball();
    if (e.key === "h" || e.key === "H") {
        player.hp = Math.min(player.maxHp, player.hp + 25);
        updatePlayerHpUI();
    }
});

window.addEventListener("keyup", e => {
    if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") keys.forward = false;
    if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") keys.back = false;
    if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") keys.left = false;
    if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") keys.right = false;
});

// ===== Fireballs =====
function spawnFireball() {
    if (!monsterState.alive) return;

    const origin = camera.position.clone();
    const dir = camera.getDirection(new BABYLON.Vector3(0, 0, 1)).normalize();

    const fbMesh = BABYLON.MeshBuilder.CreateSphere("fireball", {
        diameter: FIREBALL_RADIUS,
        segments: 8,
    }, scene);

    fbMesh.position = origin.add(dir.scale(1.0));

    const fbMat = new BABYLON.StandardMaterial("fbMat", scene);
    fbMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
    fbMat.diffuseColor = new BABYLON.Color3(0.9, 0.4, 0);
    fbMesh.material = fbMat;

    projectiles.push({
        mesh: fbMesh,
        dir: dir,
        life: FIREBALL_LIFETIME,
    });

    const yawDeg = normDeg(BABYLON.Tools.ToDegrees(camera.rotation.y));
    lastFireSpawnAngleDeg = yawDeg;
    lastFireDirAngleDeg = yawDeg;
}

// ===== Movement with ASCII collision =====
const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

function tryMove(stepVec) {
    const newPos = camera.position.add(stepVec);

    // Only check x,z against wallMap
    const { i, j } = worldToGrid(newPos.x, newPos.z);

    if (i < 0 || i >= MAP_SIZE || j < 0 || j >= MAP_SIZE) {
        return; // outside map
    }

    if (wallMap[i][j] === "#") {
        return; // blocked
    }

    camera.position = newPos;
}

// ===== Game update =====
function update(dt) {
    if (!camera) return;

    const moveForward = btnForwardHeld || keys.forward;
    const moveBack    = btnBackHeld || keys.back;
    const turnLeft    = btnTurnLeftHeld || keys.left;
    const turnRight   = btnTurnRightHeld || keys.right;

    if (turnLeft) {
        camera.rotation.y -= TURN_SPEED * dt;
    }
    if (turnRight) {
        camera.rotation.y += TURN_SPEED * dt;
    }

    const forwardDir = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
    const flatDir = new BABYLON.Vector3(forwardDir.x, 0, forwardDir.z).normalize();
    const step = MOVE_SPEED * dt;

    if (moveForward) {
        tryMove(flatDir.scale(step));
    }
    if (moveBack) {
        tryMove(flatDir.scale(-step));
    }

    // Update projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.life -= dt;
        if (p.life <= 0) {
            p.mesh.dispose();
            projectiles.splice(i, 1);
            continue;
        }

        p.mesh.position.addInPlace(p.dir.scale(FIREBALL_SPEED * dt));

        if (monsterState.alive && monsterMesh) {
            const dist = BABYLON.Vector3.Distance(p.mesh.position, monsterMesh.position);
            if (dist < 0.8) {
                monsterState.hp = Math.max(0, monsterState.hp - player.atk);
                if (monsterState.hp <= 0) {
                    monsterState.alive = false;
                    monsterMesh.dispose();
                }
                p.mesh.dispose();
                projectiles.splice(i, 1);
            }
        }
    }

    // Monster attack
    if (monsterState.alive && monsterMesh) {
        const dist = BABYLON.Vector3.Distance(camera.position, monsterMesh.position);
        monsterState.cooldown -= dt;
        if (dist <= ATTACK_RANGE && monsterState.cooldown <= 0) {
            player.hp = Math.max(0, player.hp - monsterState.atk);
            monsterState.cooldown = MONSTER_ATTACK_INTERVAL;
        }
    }

    updatePlayerHpUI();
    updateMonsterHpUI();
    updateDebugAngles(camera);
}

// ===== Main loop =====
updatePlayerHpUI();
updateMonsterHpUI();

engine.runRenderLoop(function () {
    const dt = engine.getDeltaTime() / 1000;
    update(dt);
    scene.render();
});

window.addEventListener("resize", function () {
    engine.resize();
});
</script>

</body>
</html>
